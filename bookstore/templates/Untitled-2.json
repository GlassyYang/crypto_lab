{
  "count": 20,
  "start": 0,
  "total": 1133,
  "books": [
    {
      "rating": {
        "max": 10,
        "numRaters": 656,
        "average": "8.9",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "Andrew S. Tanenbaum"
      ],
      "pubdate": "2009-7",
      "tags": [
        {
          "count": 1036,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 471,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 311,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 238,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 156,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 91,
          "name": "计算机技术",
          "title": "计算机技术"
        },
        {
          "count": 88,
          "name": "CS",
          "title": "CS"
        },
        {
          "count": 80,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "Modern Operating Systems",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3895413.jpg",
      "binding": "平装",
      "translator": [
        "陈向群",
        "马洪兵"
      ],
      "catalog": "出版者的话\n译者充\n前言\n第1章 引论\n1.1 什么是操作系统\n1.1.1 作为扩展机器的操作系统\n1.1.2 作为资源管理者的操作系统\n1.2 操作系统的历史\n1.2.1 第一代（1945～1955）：真空管和穿孔卡片\n1.2.2 第二代（1955～1965）：晶体管和批处理系统\n1.2.3 第三代（1965～1980）：集成电路芯片和多道程序设计\nl.2.4第四代（1980年至今）：个人\n计算机\n1.3 计算机硬件介绍\n1.3.1 处理器\n1.3.2 存储器\n1.3.3 磁盘\n1.3.4 磁带\n1.3.5 I／O设备\n1.3.6 总线\n1.3.7 启动计算机\n1.4 操作系统大观园\n1.4.1 大型机操作系统\n1.4.2 服务器操作系统\n1.4.3 多处理器操作系统\n1.4.4 个人计算机操作系统\n1.4.5 掌上计算机操作系统\n1.4.6 嵌入式操作系统\n1.4.7 传感器节点操作系统\n1.4.8 实时操作系统\n1.4.9 智能卡操作系统\n1.5 操作系统概念\n1.5.1 进程\n1.5.2 地址空间\n1.5.3 文件\n1.5.4 输入／输出\n1.5.5 保护\n1.5.6 shell\n1.5.7 个体重复系统发育\n1.6 系统调用\n1.6.1 用于进程管理的系统调用\n1.6.2 用于文件管理的系统调用\n1.6.3 用于目录管理的系统调用\n1.6.4 各种系统调用\n1.6.5 WindowsWin32API\n1.7 操作系统结构\n1.7.1 单体系统\n1.7.2 层次式系统\n1.7.3 微内核\n1.7.4 客户机-服务器模式\n1.7.5 虚拟机\n1.7.6 外核\n1.8 依靠C的世界\n1.8.1 C语言\n1.8.2 头文件\n1.8.3 大型编程项目\n1.8.4 运行模型\n1.9 有关操作系统的研究\n1.10 本书其他部分概要\n1.11 公制单位\n1.12 小结\n习题\n第2章 进程与线程\n2.1 进程\n2.1.1 进程模型\n2.1.2 创建进程\n2.1.3 进程的终止\n2.1.4 进程的层次结构\n2.1.5 进程的状态\n2.1.6 进程的实现\n2.1.7 多道程序设计模型\n2.2 线程\n2.2.1 线程的使用\n2.2.2 经典的线程模型\n2.2.3 POSIX线程\n2.2.4 在用户空间中实现线程\n2.2.5 在内核中实现线程\n2.2.6 混合实现\n2.2.7 调度程序激活机制\n2.2.8 弹出式线程\n2.2.9 使单线程代码多线程化\n2.3 进程间通信\n2.3.1 竞争条件\n2.3.2 临界区\n2.3.3 忙等待的互斥\n2.3.4 睡眠与唤醒\n2.3.5 信号量\n2.3.6 互斥量\n2.3.7 管程\n2.3.8 消息传递\n2.3.9 屏障\n2.4 调度\n2.4.1 调度介绍\n2.4.2 批处理系统中的调度\n2.4.3 交互式系统中的调度\n2.4.4 实时系统中的调度\n2.4.5 策略和机制\n2.4.6 线程调度\n2.5 经典的IPC问题\n2.5.1 哲学家就餐问题\n2.5.2 读者一写者问题\n2.6 有关进程和线程的研究\n2.7 小结\n习题\n第3章 存储管理\n3.1 无存储器抽象\n3.2 一种存储器抽象：地址空间\n3.2.1 地址空间的概念\n3.2.2 交换技术\n3.2.3 空闲内存管理\n3.3 虚拟内存\n3.3.1 分页\n3.3.2 页表\n3.3.3 加速分页过程\n3.3.4 针对大内存的页表\n3.4 页面置换算法\n3.4.1 最优页面置换算法\n3.4.2 最近未使用页面置换算法\n3.4.3 先进先出页面置换算法\n3.4.4 第二次机会页面置换算法\n3.4.5 时钟页面置换算法\n3.4.6 最近最少使用页面置换算法\n3.4.7 用软件模拟LRU\n3.4.8 工作集页面置换算法\n3.4.9 工作集时钟页面置换算法\n3.4.10 页面置换算法小结\n3.5 分页系统中的设计问题\n3.5.1 局部分配策略与全局分配策略\n3.5.2 负载控制\n3.5.3 页面大小\n3.5.4 分离的指令空间和数据空间\n3.5.5 共享页面\n3.5.6 共享库\n3.5.7 内存映射文件\n3.5.8 清除策略\n3.5.9 虚拟内存接口\n3.6 有关实现的问题._\n3.6.1 与分页有关的工作\n3.6.2 缺页中断处理\n3.6.3 指令备份__\n3.6.4 锁定内存中的页面\n3.6.5 后备存储\n3.6.6 策略和机制的分离\n3.7 分段\n3.7.1 纯分段的实现\n3.7.2 分段和分页结合：MULTICS\n3.7.3 分段和分页结合：Intel Pentium\n3.8 有关存储管理的研究\n3.9 小结\n习题\n第4章 文件系统\n4.1 文件\n4.1.1 文件命名\n4.1.2 文件结构\n4.1.3 文件类型\n4.1.4 文件存取\n4.1.5 文件属性\n4.1.6 文件操作\n4.1.7 使用文件系统调用的一个示例程序\n4.2 目录\n4.2.1 一级目录系统\n4.2.2 层次目录系统\n4.2.3 路径名\n4.2.4 目录操作\n4.3 文件系统的实现\n4.3.1 文件系统布局\n4.3.2 文件的实现\n4.3.3 目录的实现\n4.3.4 共享文件\n4.3.5 日志结构文件系统\n4.3.6 日志文件系统\n4.3.7 虚拟文件系统\n4.4 文件系统管理和优化\n4.4.1 磁盘空间管理\n4.4.2 文件系统备份\n4.4.3 文件系统的一致性\n4.4.4 文件系统性能\n4.4.5 磁盘碎片整理\n4.5 文件系统实例\n4.5.1 CD-ROM文件系统\n4.5.2 MS-DOS文件系统\n4.5.3 UNIXV7文件系统\n4.6 有关文件系统的研究\n4.7 小结\n习题\n第5章 输入／输出\n5.1 I／O硬件原理\n5.1.1 I／O设备\n5.1.2 设备控制器\n5.1.3 内存映射I／O\n5.1.4 直接存储器存取\n5.1.5 重温中断\n5.2 I／O软件原理\n5.2.1 I／O软件的目标\n5.2.2 程序控制I／O\n5.2.3 中断驱动I／O\n5.2.4 使用DMA的I／O\n5.3 I／O软件层次\n5.3.1 中断处理程序\n5.3.2 设备驱动程序\n5.3.3 与设备无关的I／O软件\n5.3.4 用户空间的I／O软件\n5.4 盘\n5.4.1 盘的硬件\n5.4.2 磁盘格式化\n5.4.3 磁盘臂调度算法\n5.4.4 错误处理\n5.4.5 稳定存储器\n5.5 时钟\n5.5.1 时钟硬件\n5.5.2 时钟软件\n5.5.3 软定时器\n5.6 用户界面：键盘、鼠标和监视器\n5.6.1 输入软件\n5.6.2 输出软件\n5.7 瘦客户机\n5.8 电源管理\n5.8.1 硬件问题\n5.8.2 操作系统问题\n5.8.3 应用程序问题\n5.9 有关输入／输出的研究\n5.10 小结\n习题\n第6章 死锁\n6.1 资源\n6.1.1 可抢占资源和不可抢占资源\n6.1.2 资源获取\n6.2 死锁概述\n6.2.1 资源死锁的条件\n6.2.2 死锁建模\n6.3 鸵鸟算法\n6.4 死锁检测和死锁恢复\n6.4.1 每种类型一个资源的死锁检测\n6.4.2 每种类型多个资源的死锁检测\n6.4.3 从死锁中恢复\n6.5 死锁避免\n6.5.1 资源轨迹图\n6.5.2 安全状态和不安全状态\n6.5.3 单个资源的银行家算法\n6.5.4 多个资源的银行家算法\n6.6 死锁预防\n6.6.1 破坏互斥条件\n6.6.2 破坏占有和等待条件\n6.6.3 破坏不可抢占条件\n6.6.4 破坏环路等待条件\n6.7 其他问题\n6.7.1 两阶段加锁\n6.7.2 通信死锁\n6.7.3 活锁\n6.7 -4饥饿\n6.8.有关死锁的研究\n6.9 小结\n习题\n第7章 多媒体操作系统\n7.1 多媒体简介\n7.2 多媒体文件\n7.2.1 视频编码\n7.2.2 音频编码\n7.3 视频压缩\n7.3.1 JPEG标准\n7.3.2 MPEG标准\n7.4 音频压缩\n7.5 多媒体进程调度\n7.5.1 调度同质进程\n7.5.2 一般实时调度\n7.5.3 速率单调调度\n7.5.4 最早最终时限优先调度\n7.6 多媒体文件系统范型\n7.6.1 VCR控制功能\n7.6.2 近似视频点播\n7.6.3 具有VCR功能的近似视频点播\n7.7 文件存放\n7.7.1 在单个磁盘上存放文件\n7.7.2 两个替代的文件组织策略\n7.7.3 近似视频点播的文件存放\n7.7.4 在单个磁盘上存放多个文件\n7.7.5 在多个磁盘上存放文件\n7.8 高速缓存\n7.8.1 块高速缓存\n7.8.2 文件高速缓存\n7.9 多媒体磁盘调度\n7.9.1 静态磁盘调度\n7.9.2 动态磁盘调度\n7.10 有关多媒体的研究\n7.11 小结\n习题\n第8章 多处理机系统\n8.1 多处理机\n8.1.1 多处理机硬件\n8.1.2 多处理机操作系统类型\n8.1.3 多处理机同步\n8.1.4 多处理机调度\n8.2 多计算机\n8.2.1 多计算机硬件\n8.2.2 低层通信软件\n8.2.3 用户层通信软件\n8.2.4 远程过程调用\n8.2.5 分布式共享存储器\n8.2.6 多计算机调度\n8.2.7 负载平衡\n8.3 虚拟化\n8.3.1 虚拟化的条件\n8.3.2 Ⅰ型管理程序\n8.3.3 Ⅱ型管理程序\n8.3.4 准虚拟化\n8.3.5 内存的虚拟化\n8.3.6 I／0设备的虚拟化\n8.3.7 虚拟工具\n8.3.8 多核处理机上的虚拟机\n8.3.9 授权问题\n8.4 分布式系统\n8.4.1 网络硬件\n8.4.2 网络服务和协议\n8.4.3 基于文档的中间件\n8.4.4 基于文件系统的中间件\n8.4.5 基于对象的中间件\n8.4.6 基于协作的中间件\n8.4.7 网格\n8.5 有关多处理机系统的研究\n8.6 小结\n习题\n第9章 安全\n第10章 实例研究1：Linux\n第11章 实例研究2：Windows Visa\n第12章 实例研究3：Symbian操作系统\n第13章 操作系统设计\n第14章 阅读材料及参考文献",
      "pages": "582",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s3895413.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s3895413.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3895413.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/3852290\/",
      "id": "3852290",
      "publisher": "机械工业出版社",
      "isbn10": "7111255445",
      "isbn13": "9787111255444",
      "title": "现代操作系统（第3版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/3852290",
      "alt_title": "Modern Operating Systems",
      "author_intro": "Andrew S.Tanenbaum  拥有美国麻省理工学院的理学学士学位和加州大学伯克利分校的哲学博士学位，目前是荷兰阿姆斯特丹Vrije大学的计算机科学系教授，并领导着一个计算机系统的研究小组。多年来，他在操作系统、编译技术、网络及局域分布式系统方面进行了大量的研究工作，并在各种学术杂志及会议上发表了多篇论文，同时还是5本计算机专著的作者。Tanenbaurn是ACM会员、IEEE资深会员、荷兰皇家艺术和科学学院院士，多次获得计算机教育杰出贡献奖。他还入选了《世界名人录》。",
      "summary": "本书是操作系统领域的经典之作，与第2版相比，增加了关于Linux、Windows Vista和Symbian操作系统的详细介绍。书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入\/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理机上的虚拟机以及操作系统设计等方面的内容。此外，还在第2版的基础上对部分习题进行了增删，更有助于读者学习和对知识的理解及掌握。\n本书适合作为高等院校计算机专业操作系统课程教材，也是设计、开发操作系统的重要参考书。\nTanenbaum教授作为三个操作系统的设计师或联合设计师，具有长期设计开发操作系统的经验，从而把其对理论的深入理解和具体实践融入书中，使本书成为操作系统领域的经典之作。\n在本书第3版中，作者深入讨论了许多主题，包括：进程、线程、存储管理、文件系统、I\/O、死锁、接口设计、多媒体、性能权衡，以及有关操作系统设计的最新趋势。书中不仅涵盖了现代操作系统的原理和实践，而且特别关注了Linux操作系统、Windows Vista操作系统、嵌入式操作系统、实时操作系统以及多媒体操作系统。\n本书特色：\n● 涉及Windows Vista以及最新的Linux\/UNIX操作系统。\n● 用一整章(第12章)的篇幅对用于移动设备的Symbian操作系统进行分析。\n● 涵盖更多、更新的安全方面的内容。\n● 重新组织内容，尽早论述关键抽象概念。\n● 给出与未来操作系统发展有关的新研究成果。\n● 更新和增加了编程练习。\n● 在线操作系统练习(http:\/\/www.prenhall.com\/tanenbaum\/details.html)采用主流Windows操作系统以及开源工具。\n● 包括操作系统模拟练习。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "75.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 313,
        "average": "8.6",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "（荷）Andrew S. Tanenbaum"
      ],
      "pubdate": "2005-9-1",
      "tags": [
        {
          "count": 323,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 165,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 99,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 71,
          "name": "os",
          "title": "os"
        },
        {
          "count": 69,
          "name": "现代操作系统",
          "title": "现代操作系统"
        },
        {
          "count": 34,
          "name": "tanenbaum",
          "title": "tanenbaum"
        },
        {
          "count": 25,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 21,
          "name": "kernel",
          "title": "kernel"
        }
      ],
      "origin_title": "Modern Operating Systems, Second Edition",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1527031.jpg",
      "binding": "平装(无盘)",
      "translator": [
        "陈向群",
        "马洪兵"
      ],
      "catalog": "",
      "pages": "568",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1527031.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1527031.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1527031.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1390650\/",
      "id": "1390650",
      "publisher": "机械工业出版社",
      "isbn10": "711116511X",
      "isbn13": "9787111165118",
      "title": "现代操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1390650",
      "alt_title": "Modern Operating Systems, Second Edition",
      "author_intro": "坦尼鲍姆,是ACM和IEEE的资深会员，荷兰皇家艺术和科学学院院士，获得过1997年度ACM\/SIGCSE计算机科学教育杰出贡献奖。当前，他的主要研究方向是设计规模达十亿级用户的广域分布式系统。在进行这些研究项目的基础上，他在各种学术杂志及会议上发表了70多篇论文，并出版了多本计算机专著。他还入选了《世界名人录》。他的个人主页是:http\/\/www.cs.vu",
      "summary": "本书是操作系统领域的经典之作，与第1版相比有较大的变化。书中集中讨论了操作系统的基本原理，除了重点放在单处理机操作系统之处，还包含了有关计算机安全、多媒体操作系统、UNIX、Window2000以及操作系统设计等方面的内容。书中涉及的主题包括图形用户界面、多处理机操作系统、笔记本电脑电源管理、可信系统、病毒、网络终端、CD-ROM文件系统、互斥信号量、RAID、软定时器、稳定存储器以及新的页面置换算法等。此外，书中还增加了大量习题，方便教学。\n本书适合作为高等院校计算机科学与技术专业操作系统课程教材，也是设计、开发操作系统的重要参考书。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "55.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 93,
        "average": "9.2",
        "min": 0
      },
      "subtitle": "（英文版·第3版）",
      "author": [
        "Andrew S.Tanenbaum"
      ],
      "pubdate": "2009-4",
      "tags": [
        {
          "count": 115,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 59,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 37,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 23,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 15,
          "name": "经典原版书库",
          "title": "经典原版书库"
        },
        {
          "count": 10,
          "name": "CS",
          "title": "CS"
        },
        {
          "count": 9,
          "name": "计算机科学技术",
          "title": "计算机科学技术"
        },
        {
          "count": 9,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "Modern Operating System",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3724543.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "",
      "pages": "1076",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s3724543.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s3724543.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3724543.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/3667744\/",
      "id": "3667744",
      "publisher": "机械工业出版社",
      "isbn10": "7111265270",
      "isbn13": "9787111265276",
      "title": "现代操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/3667744",
      "alt_title": "Modern Operating System",
      "author_intro": "Tanenbaum教授作为三个操作系统的设计师或联合设计师，具有长期设计开发操作系统的经验，从而把其对理论的深入理解和具体实践融入书中，使本书成为操作系统领域的经典之作。.\n在本书第3版中，作者深入讨论了许多主题，包括：进程、线程、存储管理、文件系统、I／O、死锁、接口设计、多媒体、性能权衡，以及有关操作系统设计的最新趋势。书中不仅涵盖了现代操作系统的原理和实践，而且特别关注了Linux操作系统、Windows Vista操作系统。嵌入式操作系统、实时操作系统以及多媒体操作系统。..",
      "summary": "《现代操作系统(英文版第3版)》内容为：Tanenbaum教授作为三个操作系统的设计师或联合设计师，具有长期设计开发操作系统的经验，从而把其对理论的深入理解和具体实践融入书中，使《现代操作系统(英文版第3版)》成为操作系统领域的经典之作。在《现代操作系统(英文版第3版)》第3版中，作者深入讨论了许多主题，包括：进程，线程，存储管理，文件系统，I／O死锁，接口设计，多媒体，性能权衡。以及有关操作系统设计的最新趋势。书中不仅涵盖了现代操作系统的原理和实践，而且特别关注了Linux操作系统，WindowsVista操作系统、嵌入式操作系统、实时操作系统以及多媒体操作系统。\n·涉及Windows Vista以及最新的Linux／Unix操作系统。\n·用一整章(第12章)的篇幅对用于移动设备的Syrnbian操作系统进行案例分析。\n·涵盖更多，更新的安全方面的内容。\n·重新组织内容，尽早论述关键抽象概念。\n·给出与未来操作系统发展有关的新研究成果。\n·更新和增加了编程练习。\n·在线操作系统练习(http：／／www prenhall．com／anenbaum／details．html)采用主流windows操作系统以及开源工具。\n·包括操作系统模拟练习。\n\n海报：",
      "series": {
        "id": "1895",
        "title": "经典原版书库"
      },
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 55,
        "average": "9.1",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[荷] Andrew S. Tanenbaum",
        "[荷] Herbert Bos"
      ],
      "pubdate": "2017-7",
      "tags": [
        {
          "count": 90,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 40,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 38,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 24,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 17,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 16,
          "name": "计算机技术",
          "title": "计算机技术"
        },
        {
          "count": 15,
          "name": "经典",
          "title": "经典"
        },
        {
          "count": 12,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "Modern Operating Systems (4th Edition)",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29633301.jpg",
      "binding": "平装",
      "translator": [
        "陈向群",
        "马洪兵 等"
      ],
      "catalog": "目录\n出版者的话\n译者序\n前言\n作者简介\n第1章　引论\t1\n1.1　什么是操作系统\t2\n1.1.1　作为扩展机器的操作系统\t2\n1.1.2　作为资源管理者的操作系统\t3\n1.2　操作系统的历史\t4\n1.2.1　第一代（1945～1955）：真空管和穿孔卡片\t4\n1.2.2　第二代（1955～1965）：晶体管和批处理系统\t4\n1.2.3　第三代（1965～1980）：集成电路和多道程序设计\t6\n1.2.4　第四代（1980年至今）：个人计算机\t8\n1.2.5　第五代（1990年至今）：移动计算机\t10\n1.3　计算机硬件简介\t11\n1.3.1　处理器\t12\n1.3.2　存储器\t14\n1.3.3　磁盘\t15\n1.3.4　I\/O设备\t16\n1.3.5　总线\t18\n1.3.6　启动计算机\t19\n1.4　操作系统大观园\t20\n1.4.1　大型机操作系统\t20\n1.4.2　服务器操作系统\t20\n1.4.3　多处理器操作系统\t20\n1.4.4　个人计算机操作系统\t20\n1.4.5　掌上计算机操作系统\t21\n1.4.6　嵌入式操作系统\t21\n1.4.7　传感器节点操作系统\t21\n1.4.8　实时操作系统\t21\n1.4.9　智能卡操作系统\t21\n1.5　操作系统概念\t22\n1.5.1　进程\t22\n1.5.2　地址空间\t23\n1.5.3　文件\t23\n1.5.4　输入\/输出\t25\n1.5.5　保护\t25\n1.5.6　shell\t25\n1.5.7　个体重复系统发育\t26\n1.6　系统调用\t28\n1.6.1　用于进程管理的系统调用\t31\n1.6.2　用于文件管理的系统调用\t32\n1.6.3　用于目录管理的系统调用\t32\n1.6.4　各种系统调用\t34\n1.6.5　Windows Win32 API\t34\n1.7　操作系统结构\t35\n1.7.1　单体系统\t36\n1.7.2　层次式系统\t36\n1.7.3　微内核\t37\n1.7.4　客户端–服务器模式\t38\n1.7.5　虚拟机\t39\n1.7.6　外核\t41\n1.8　依靠C的世界\t41\n1.8.1　C语言\t41\n1.8.2　头文件\t41\n1.8.3　大型编程项目\t43\n1.8.4　运行模型\t43\n1.9　有关操作系统的研究\t44\n1.10　本书其他部分概要\t45\n1.11　公制单位\t45\n1.12　小结\t46\n习题\t46\n第2章　进程与线程\t48\n2.1　进程\t48\n2.1.1　进程模型\t48\n2.1.2　进程的创建\t49\n2.1.3　进程的终止\t51\n2.1.4　进程的层次结构\t51\n2.1.5　进程的状态\t51\n2.1.6　进程的实现\t53\n2.1.7　多道程序设计模型\t54\n2.2　线程\t54\n2.2.1　线程的使用\t54\n2.2.2　经典的线程模型\t57\n2.2.3　POSIX线程\t60\n2.2.4　在用户空间中实现线程\t60\n2.2.5　在内核中实现线程\t63\n2.2.6　混合实现\t63\n2.2.7　调度程序激活机制\t64\n2.2.8　弹出式线程\t64\n2.2.9　使单线程代码多线程化\t65\n2.3　进程间通信\t67\n2.3.1　竞争条件\t67\n2.3.2　临界区\t68\n2.3.3　忙等待的互斥\t68\n2.3.4　睡眠与唤醒\t71\n2.3.5　信号量\t73\n2.3.6　互斥量\t74\n2.3.7　管程\t78\n2.3.8　消息传递\t81\n2.3.9　屏障\t82\n2.3.10　避免锁：读–复制–更新\t83\n2.4　调度\t84\n2.4.1　调度简介\t84\n2.4.2　批处理系统中的调度\t88\n2.4.3　交互式系统中的调度\t89\n2.4.4　实时系统中的调度\t92\n2.4.5　策略和机制\t93\n2.4.6　线程调度\t93\n2.5　经典的IPC问题\t94\n2.5.1　哲学家就餐问题\t94\n2.5.2　读者–写者问题\t96\n2.6　有关进程与线程的研究\t97\n2.7　小结\t97\n习题\t98\n第3章　内存管理\t102\n3.1　无存储器抽象\t102\n3.2　一种存储器抽象：地址空间\t104\n3.2.1　地址空间的概念\t104\n3.2.2　交换技术\t106\n3.2.3　空闲内存管理\t107\n3.3　虚拟内存\t109\n3.3.1　分页\t110\n3.3.2　页表\t112\n3.3.3　加速分页过程\t112\n3.3.4　针对大内存的页表\t114\n3.4　页面置换算法\t117\n3.4.1　最优页面置换算法\t117\n3.4.2　最近未使用页面置换算法\t118\n3.4.3　先进先出页面置换算法\t118\n3.4.4　第二次机会页面置换算法\t118\n3.4.5　时钟页面置换算法\t119\n3.4.6　最近最少使用页面置换算法\t119\n3.4.7　用软件模拟LRU\t120\n3.4.8　工作集页面置换算法\t121\n3.4.9　工作集时钟页面置换算法\t123\n3.4.10　页面置换算法小结\t124\n3.5　分页系统中的设计问题\t124\n3.5.1　局部分配策略与全局分配策略\t124\n3.5.2　负载控制\t126\n3.5.3　页面大小\t126\n3.5.4　分离的指令空间和数据空间\t127\n3.5.5　共享页面\t128\n3.5.6　共享库\t128\n3.5.7　内存映射文件\t130\n3.5.8　清除策略\t130\n3.5.9　虚拟内存接口\t130\n3.6　有关实现的问题\t131\n3.6.1　与分页有关的工作\t131\n3.6.2　缺页中断处理\t131\n3.6.3　指令备份\t132\n3.6.4　锁定内存中的页面\t132\n3.6.5　后备存储\t133\n3.6.6　策略和机制的分离\t134\n3.7　分段\t134\n3.7.1　纯分段的实现\t136\n3.7.2　分段和分页结合：MULTICS\t136\n3.7.3　分段和分页结合：Intel x86\t138\n3.8　有关内存管理的研究\t141\n3.9　小结\t141\n习题\t142\n第4章　文件系统\t147\n4.1　文件\t148\n4.1.1　文件命名\t148\n4.1.2　文件结构\t149\n4.1.3　文件类型\t149\n4.1.4　文件访问\t151\n4.1.5　文件属性\t151\n4.1.6　文件操作\t152\n4.1.7　使用文件系统调用的一个示例程序\t152\n4.2　目录\t154\n4.2.1　一级目录系统\t154\n4.2.2　层次目录系统\t154\n4.2.3　路径名\t154\n4.2.4　目录操作\t156\n4.3　文件系统的实现\t157\n4.3.1　文件系统布局\t157\n4.3.2　文件的实现\t157\n4.3.3　目录的实现\t160\n4.3.4　共享文件\t162\n4.3.5　日志结构文件系统\t163\n4.3.6　日志文件系统\t164\n4.3.7　虚拟文件系统\t165\n4.4　文件系统管理和优化\t167\n4.4.1　磁盘空间管理\t167\n4.4.2　文件系统备份\t171\n4.4.3　文件系统的一致性\t174\n4.4.4　文件系统性能\t176\n4.4.5　磁盘碎片整理\t178\n4.5　文件系统实例\t179\n4.5.1　MS-DOS文件系统\t179\n4.5.2　UNIX V7文件系统\t181\n4.5.3　CD-ROM文件系统\t182\n4.6　有关文件系统的研究\t185\n4.7　小结\t185\n习题\t186\n第5章　输入\/输出\t189\n5.1　I\/O硬件原理\t189\n5.1.1　I\/O设备\t189\n5.1.2　设备控制器\t190\n5.1.3　内存映射I\/O\t190\n5.1.4　直接存储器存取\t192\n5.1.5　重温中断\t194\n5.2　I\/O软件原理\t196\n5.2.1　I\/O软件的目标\t196\n5.2.2　程序控制I\/O\t197\n5.2.3　中断驱动I\/O\t198\n5.2.4　使用DMA的I\/O\t199\n5.3　I\/O软件层次\t199\n5.3.1　中断处理程序\t199\n5.3.2　设备驱动程序\t200\n5.3.3　与设备无关的I\/O软件\t202\n5.3.4　用户空间的I\/O软件\t205\n5.4　盘\t206\n5.4.1　盘的硬件\t206\n5.4.2　磁盘格式化\t211\n5.4.3　磁盘臂调度算法\t213\n5.4.4　错误处理\t215\n5.4.5　稳定存储器\t216\n5.5　时钟\t218\n5.5.1　时钟硬件\t218\n5.5.2　时钟软件\t219\n5.5.3　软定时器\t221\n5.6　用户界面：键盘、鼠标和监视器\t222\n5.6.1　输入软件\t222\n5.6.2　输出软件\t225\n5.7　瘦客户机\t235\n5.8　电源管理\t236\n5.8.1　硬件问题\t236\n5.8.2　操作系统问题\t237\n5.8.3　应用程序问题\t241\n5.9　有关输入\/输出的研究\t241\n5.10　小结\t242\n习题\t243\n第6章　死锁\t247\n6.1　资源\t247\n6.1.1　可抢占资源和不可抢占资源\t247\n6.1.2　资源获取\t248\n6.2　死锁简介\t249\n6.2.1　资源死锁的条件\t249\n6.2.2　死锁建模\t249\n6.3　鸵鸟算法\t251\n6.4　死锁检测和死锁恢复\t251\n6.4.1　每种类型一个资源的死锁检测\t252\n6.4.2　每种类型多个资源的死锁检测\t253\n6.4.3　从死锁中恢复\t254\n6.5　死锁避免\t255\n6.5.1　资源轨迹图\t255\n6.5.2　安全状态和不安全状态\t256\n6.5.3　单个资源的银行家算法\t257\n6.5.4　多个资源的银行家算法\t257\n6.6　死锁预防\t258\n6.6.1　破坏互斥条件\t258\n6.6.2　破坏占有并等待条件\t259\n6.6.3　破坏不可抢占条件\t259\n6.6.4　破坏环路等待条件\t259\n6.7　其他问题\t260\n6.7.1　两阶段加锁\t260\n6.7.2　通信死锁\t260\n6.7.3　活锁\t261\n6.7.4　饥饿\t262\n6.8　有关死锁的研究\t262\n6.9　小结\t263\n习题\t263\n第7章　虚拟化和云\t267\n7.1　历史\t268\n7.2　虚拟化的必要条件\t268\n7.3　第一类和第二类虚拟机管理程序\t270\n7.4　高效虚拟化技术\t271\n7.4.1　在不支持虚拟化的平台上实现虚拟化\t271\n7.4.2　虚拟化的开销\t273\n7.5　虚拟机管理程序是正确的微内核吗\t273\n7.6　内存虚拟化\t275\n7.7　I\/O虚拟化\t277\n7.8　虚拟装置\t279\n7.9　多核CPU上的虚拟机\t279\n7.10　授权问题\t279\n7.11　云\t280\n7.11.1　云即服务\t280\n7.11.2　虚拟机迁移\t280\n7.11.3　检查点\t281\n7.12　案例研究：VMware\t281\n7.12.1　VMware的早期历史\t281\n7.12.2　VMware Workstation\t282\n7.12.3　将虚拟化引入x86的挑战\t282\n7.12.4　VMware Workstation解决方案概览\t283\n7.12.5　VMware Workstation的演变\t288\n7.12.6　VMware的第一类虚拟机管理程序ESX Server\t288\n7.13　有关虚拟化和云的研究\t289\n习题\t289\n第8章　多处理机系统\t291\n8.1　多处理机\t292\n8.1.1　多处理机硬件\t292\n8.1.2　多处理机操作系统类型\t298\n8.1.3　多处理机同步\t301\n8.1.4　多处理机调度\t303\n8.2　多计算机\t306\n8.2.1　多计算机硬件\t307\n8.2.2　低层通信软件\t309\n8.2.3　用户层通信软件\t311\n8.2.4　远程过程调用\t313\n8.2.5　分布式共享存储器\t314\n8.2.6　多计算机调度\t317\n8.2.7　负载平衡\t318\n8.3　分布式系统\t319\n8.3.1　网络硬件\t321\n8.3.2　网络服务和协议\t323\n8.3.3　基于文档的中间件\t325\n8.3.4　基于文件系统的中间件\t326\n8.3.5　基于对象的中间件\t329\n8.3.6　基于协作的中间件\t330\n8.4　有关多处理机系统的研究\t332\n8.5　小结\t332\n习题\t333\n第9章　安全\t336\n9.1　环境安全\t337\n9.1.1　威胁\t337\n9.1.2　入侵者\t339\n9.2　操作系统完全\t339\n9.2.1　可信系统\t339\n9.2.2　可信计算基\t340\n9.3　保护机制\t341\n9.3.1　保护域\t341\n9.3.2　访问控制列表\t342\n9.3.3　权能字\t344\n9.4　安全系统的形式化模型\t345\n9.4.1　多级安全\t346\n9.4.2　隐蔽信道\t348\n9.5　密码学原理\t350\n9.5.1　私钥加密技术\t351\n9.5.2　公钥加密技术\t351\n9.5.3　单向函数\t352\n9.5.4　数字签名\t352\n9.5.5　可信平台模块\t353\n9.6　认证\t354\n9.6.1　使用物理识别的认证方式\t358\n9.6.2　使用生物识别的认证方式\t360\n9.7　软件漏洞\t361\n9.7.1　缓冲区溢出攻击\t361\n9.7.2　格式化字符串攻击\t367\n9.7.3　悬垂指针\t369\n9.7.4　空指针间接引用攻击\t369\n9.7.5　整数溢出攻击\t370\n9.7.6　命令注入攻击\t370\n9.7.7　检查时间\/使用时间攻击\t371\n9.8　内部攻击\t371\n9.8.1　逻辑炸弹\t371\n9.8.2　后门陷阱\t372\n9.8.3　登录欺骗\t372\n9.9　恶意软件\t373\n9.9.1　特洛伊木马\t374\n9.9.2　病毒\t375\n9.9.3　蠕虫\t381\n9.9.4　间谍软件\t382\n9.9.5　rootkit\t384\n9.10　防御\t386\n9.10.1　防火墙\t387\n9.10.2　反病毒和抑制反病毒技术\t388\n9.10.3　代码签名\t392\n9.10.4　囚禁\t392\n9.10.5　基于模型的入侵检测\t393\n9.10.6　封装移动代码\t394\n9.10.7　Java安全性\t396\n9.11　有关安全的研究\t397\n9.12　小结\t398\n习题\t398\n第10章　实例研究1：UNIX、Linux和Android\t403\n10.1　UNIX与Linux的历史\t403\n10.1.1　UNICS\t403\n10.1.2　PDP-11 UNIX\t404\n10.1.3　可移植的UNIX\t404\n10.1.4　Berkeley UNIX\t405\n10.1.5　标准UNIX\t405\n10.1.6　MINIX\t406\n10.1.7　Linux\t407\n10.2　Linux简介\t408\n10.2.1　Linux的设计目标\t408\n10.2.2　到Linux的接口\t409\n10.2.3　shell\t410\n10.2.4　Linux应用程序\t412\n10.2.5　内核结构\t413\n10.3　Linux中的进程\t414\n10.3.1　基本概念\t414\n10.3.2　Linux中进程管理相关的系统调用\t416\n10.3.3　Linux中进程与线程的实现\t418\n10.3.4　Linux中的调度\t422\n10.3.5　启动Linux系统\t425\n10.4　Linux中的内存管理\t426\n10.4.1　基本概念\t427\n10.4.2　Linux中的内存管理系统调用\t429\n10.4.3　Linux中内存管理的实现\t429\n10.4.4　Linux中的分页\t433\n10.5　Linux中的I\/O系统\t434\n10.5.1　基本概念\t434\n10.5.2　网络\t435\n10.5.3　Linux中的I\/O系统调用\t436\n10.5.4　I\/O在Linux中的实现\t437\n10.5.5　Linux中的模块\t439\n10.6　Linux文件系统\t439\n10.6.1　基本概念\t439\n10.6.2　Linux中的文件系统调用\t442\n10.6.3　Linux文件系统的实现\t444\n10.6.4　NFS：网络文件系统\t449\n10.7　Linux的安全性\t452\n10.7.1　基本概念\t452\n10.7.2　Linux中安全相关的系统调用\t454\n10.7.3　Linux中的安全实现\t454\n10.8　Android\t455\n10.8.1　Android与Google\t455\n10.8.2　Android的历史\t455\n10.8.3　设计目标\t457\n10.8.4　Android体系结构\t458\n10.8.5　Linux扩展\t459\n10.8.6　Dalvik\t461\n10.8.7　Binder IPC\t462\n10.8.8　Android应用\t467\n10.8.9　意图\t475\n10.8.10　应用程序沙箱\t475\n10.8.11　安全性\t476\n10.8.12　进程模型\t479\n10.9　小结\t482\n习题\t483\n第11章　实例研究2：Windows 8\t487\n11.1　Windows 8.1的历史\t487\n11.1.1　20世纪80年代：MS-DOS\t487\n11.1.2　20世纪90年代：基于MS-DOS的Windows\t488\n11.1.3　21世纪00年代：基于NT的Windows\t488\n11.1.4　Windows Vista\t489\n11.1.5　21世纪10年代：现代Windows\t490\n11.2　Windows 编程\t490\n11.2.1　原生NT应用编程接口\t493\n11.2.2　Win32应用编程接口\t494\n11.2.3　Windows注册表\t496\n11.3　系统结构\t498\n11.3.1　操作系统结构\t498\n11.3.2　启动Windows \t506\n11.3.3　对象管理器的实现\t507\n11.3.4　子系统、DLL和用户态服务\t513\n11.4　Windows中的进程和线程\t514\n11.4.1　基本概念\t514\n11.4.2　作业、进程、线程和纤程管理API调用\t518\n11.4.3　进程和线程的实现\t521\n11.5　内存管理\t525\n11.5.1　基本概念\t525\n11.5.2　内存管理系统调用\t527\n11.5.3　存储管理的实现\t528\n11.6　Windows的高速缓存\t533\n11.7　Windows的I\/O\t534\n11.7.1　基本概念\t534\n11.7.2　I\/O的API调用\t535\n11.7.3　I\/O实现\t536\n11.8　Windows NT文件系统\t539\n11.8.1　基本概念\t540\n11.8.2　NTFS文件系统的实现\t540\n11.9　Windows电源管理\t546\n11.10　Windows 8中的安全\t547\n11.10.1　基本概念\t548\n11.10.2　安全相关的API调用\t548\n11.10.3　安全实现\t549\n11.10.4　安全缓解技术\t551\n11.11　小结\t552\n习题\t553\n第12章　操作系统设计\t556\n12.1　设计问题的本质\t556\n12.1.1　目标\t556\n12.1.2　设计操作系统为什么困难\t557\n12.2　接口设计\t558\n12.2.1　指导原则\t558\n12.2.2　范型\t559\n12.2.3　系统调用接口\t561\n12.3　实现\t563\n12.3.1　系统结构\t563\n12.3.2　机制与策略\t565\n12.3.3　正交性\t566\n12.3.4　命名\t566\n12.3.5　绑定的时机\t567\n12.3.6　静态与动态结构\t567\n12.3.7　自顶向下与自底向上的实现\t568\n12.3.8　同步通信与异步通信\t568\n12.3.9　实用技术\t569\n12.4　性能\t572\n12.4.1　操作系统为什么运行缓慢\t572\n12.4.2　什么应该优化\t573\n12.4.3　空间–时间的权衡\t573\n12.4.4　缓存\t575\n12.4.5　线索\t575\n12.4.6　利用局部性\t576\n12.4.7　优化常见的情况\t576\n12.5　项目管理\t576\n12.5.1　人月神话\t576\n12.5.2　团队结构\t577\n12.5.3　经验的作用\t578\n12.5.4　没有银弹\t579\n12.6　操作系统设计的趋势\t579\n12.6.1　虚拟化与云\t579\n12.6.2　众核芯片\t580\n12.6.3　大型地址空间操作系统\t580\n12.6.4　无缝的数据访问\t580\n12.6.5　电池供电的计算机\t581\n12.6.6　嵌入式系统\t581\n12.7　小结\t581\n习题\t582\n第13章　参考书目与文献\t584\n13.1　进行深入阅读的建议\t584\n13.1.1　引论\t584\n13.1.2　进程与线程\t584\n13.1.3　内存管理\t585\n13.1.4　文件系统\t585\n13.1.5　输入\/输出\t585\n13.1.6　死锁\t586\n13.1.7　虚拟化和云\t586\n13.1.8　多处理机系统\t586\n13.1.9　安全\t587\n13.1.10　实例研究1：UNIX、Linux和Android\t588\n13.1.11　实例研究2：Windows 8\t588\n13.1.12　操作系统设计\t589\n13.2　按字母顺序排序的参考文献\t589",
      "pages": "610",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s29633301.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s29633301.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s29633301.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/27096665\/",
      "id": "27096665",
      "publisher": "机械工业出版社",
      "isbn10": "7111573692",
      "isbn13": "9787111573692",
      "title": "现代操作系统（原书第4版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/27096665",
      "alt_title": "Modern Operating Systems (4th Edition)",
      "author_intro": "Andrew S. Tanenbaum拥有麻省理工学院的理学学士学位和加州大学伯克利分校的博士学位，如今他是阿姆斯特丹自由大学计算机科学学院的教授。他曾经是计算与图像高级学院的院长，这是一个跨大学的研究生院，主要研究高级并行、分布式以及图像系统。他同时也是荷兰皇家艺术与科学院的教授，这使得他没有变成一个刻板的人。他还赢得过享有盛名的欧洲研究理事会卓越贡献奖。\n过去一段时间，他的主要研究方向是编译器、操作系统、网络以及分布式系统。现在他的主要研究方向是安全可靠的操作系统。他在这个研究方向已经发表了超过175篇经常被引用的期刊和会议论文。Tanenbaum教授还撰写或参与撰写了5本教材，并被翻译成20种语言，其中包括巴斯克语和泰语。这些教材被全球的大学使用，总计有163个版本（语言和版本加起来）。\nTanenbaum教授还编写了大量的软件，特别是MINIX，这是一个小型的UNIX。其灵感直接源于Linux以及Linux最初开发的平台。如今的MINIX版本是MINIX 3，专注于成为一个非常可靠和安全的操作系统。只有当任何用户都不会遭遇操作系统崩溃的情况时，Tanenbaum教授才认为他完成了自己的工作。MINIX 3是一个欢迎所有人来完善的开放源代码项目，请访问www.minix3.org下载MINIX 3的免费版本，并试着运行它。x86和ARM版本都可用。\nTanenbaum教授的博士生在毕业后都有很好的前途，对于这一点教授本人非常自豪。在这方面，他如同一只爱孩子的母鸡。\nTanenbaum教授是ACM会士、IEEE会士，也是荷兰皇家艺术与科学院院士。他荣获了相当多的ACM、IEEE和USENIX奖项。如果你对此感到好奇，可以去他的Wikipedia主页查看。他还有两个荣誉博士学位。\nHerbert Bos在特温特大学获得硕士学位，在剑桥大学计算机实验室获得博士学位。此后，他为Linux等操作系统的可信I\/O架构做了大量工作，同时也基于MINIX 3研究系统。他现在是阿姆斯特丹自由大学计算机科学学院系统与网络安全系的教授，主要研究方向是系统安全。他与学生一起以新颖的方式检测并阻止攻击，分析并对恶意软件进行反向工程，还共同拆卸过僵尸网络（横跨几百万台计算机的恶意网络基础设施）。2011年，他因在反向工程领域的研究获得了ERC奖。他的三个学生因所写的与系统相关的论文被评为欧洲最佳博士论文而获得了Roger Needham奖。",
      "summary": "Andrew S. Tanenbaum教授编写的教材《现代操作系统》现在已经是第4版了。第4版在保持原有特色的基础上，又增添了许多新的内容，反映了当代操作系统的发展与动向，并不断地与时俱进。\n对比第3版，第4版有很多变化。一些是教材中多处可见的细微变化，一些是就某一功能或机制增加了对最新技术的介绍，如增加了futex同步原语、读–复制–更新（Read-Copy-Update）机制以及6级RAID的内容。另外一些则是重大变化，例如：用Windows 8替换了Vista的内容；用相当大的篇幅介绍了移动终端应用最广泛、发展最快的Android，以替换原来Symbian的内容；增加了新的一章，介绍目前最流行的虚拟化和云技术，其中还包括典型案例VMware。很多章节在内容安排上也有较大的改动，例如：第8章对多处理机系统的内容进行了大幅更新；第9章对安全的内容进行了大量修改和重新组织，增加了对缺陷代码、恶意软件进行探查和防御的新内容，对于空指针引用和缓冲区溢出等攻击行为提出了更详细的应对方法，并从攻击路径入手，详细论述了包含金丝雀（canary）保护、不执行（NX）位以及地址空间随机化在内的防御机制。最后的参考文献也进行了更新，收录了本书第3版推出后发表的新论文。大部分章节最后的相关研究部分都完全重写了，以反映最新的操作系统研究成果。\n本教材还增添了一名合著者—来自阿姆斯特丹自由大学的 Herbert Bos教授，他是一名全方位的系统专家，尤其擅长安全和UNIX方面。\nTanenbaum教授的教材还有一个特点，就是丰富的、引发思考的习题。所有章节后面都附有大量的习题，完成这些习题很不容易，需要花费很长时间，在深入理解操作系统精髓的基础上才能作答。这些习题很灵活，并且与实际系统相结合，既考核对基本概念、工作原理的理解，又考核实际动手能力。\nTanenbaum教授的教材是需要细细阅读的，字里行间体现了他对设计与实现操作系统的各种技术的深入思考。正因为Tanenbaum教授自己设计开发了一个小型、真实的操作系统MINIX，所以通过他在教材中的讲述，读者可以了解实现操作系统时应该考虑哪些问题、注重哪些细节。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "89.00"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 60,
        "average": "9.1",
        "min": 0
      },
      "subtitle": "英文版·第二版",
      "author": [
        "特纳鲍姆"
      ],
      "pubdate": "2002-1",
      "tags": [
        {
          "count": 37,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 28,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 19,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 8,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 8,
          "name": "Tanenbaum",
          "title": "Tanenbaum"
        },
        {
          "count": 7,
          "name": "经典",
          "title": "经典"
        },
        {
          "count": 6,
          "name": "教材",
          "title": "教材"
        },
        {
          "count": 6,
          "name": "原版教材",
          "title": "原版教材"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1305284.jpg",
      "binding": "平装(无盘)",
      "translator": [],
      "catalog": "PREFACE\n1 INTRODUCTION\n2 PROCESSES AND THREADS\n3 DEADLOCKS\n4 MEMORY MANAGEMENT\n5 INPUT\/OUTPUT\n6 FILE SYSTEMS\n7 MULTIMEDIA OPERATING SYSTEMS\n8 MUL TIPLE PROCESSOR SYSTEMS\n9 SECURITY\n10 CASE STUDY 1:UNIX AND LINUX\n11 CASE STUDY 2:WINDOWS 2000\n12 OPERATING SYSTEM DESING\n13 READING LIST AND BIBLIOGRAPHY\nINDEX",
      "pages": "951",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1305284.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1305284.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1305284.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1231692\/",
      "id": "1231692",
      "publisher": "机械工业出版社",
      "isbn10": "7111091566",
      "isbn13": "9787111091561",
      "title": "现代操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1231692",
      "alt_title": "",
      "author_intro": "",
      "summary": "《现代操作系统(英文版)(第2版)》内容包括：INTRODUCTION、PROCESSES AND THREADS、DEADLOCKS、MEMORY MANAGEMENT、INPUTIOUTPUT、FILE SYSTEMS、MULTIMEDIA OPERATING SYSTEMS、MULTIPLE PROCESSOR SYSTEMS、SECURITY、CASE STUDY 1: UNIX AND LINUX等。",
      "price": "48.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 31,
        "average": "7.9",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "坦尼鲍姆"
      ],
      "pubdate": "1999-11",
      "tags": [
        {
          "count": 19,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 12,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 5,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 4,
          "name": "美国",
          "title": "美国"
        },
        {
          "count": 4,
          "name": "教材",
          "title": "教材"
        },
        {
          "count": 2,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 2,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 2,
          "name": "linux",
          "title": "linux"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s9142891.jpg",
      "binding": "平装",
      "translator": [
        "陈向群\/等"
      ],
      "catalog": "目 录\n译者序\n前言\n第一部分 传统操作系统\n第1章 引言\n1.1什么是操作系统\n1.1.1作为扩展机器的操作系统\n1.1.2作为资源管理器的操作系统\n1.2操作系统历史\n1.2.1第一代计算机（1945～1955）：真空管和插件板\n1.2.2第二代计算机（1955～1965）：晶体管和批处理系统\n1.2.3第三代计算机（1965～1980）：集成电路芯片和多道程序\n1.2.4第四代计算机（1980～1990）：个人计算机\n1.3操作系统基本概念\n1.3.1进程\n1.3.2文件\n1.3.3系统调用\n1.3.4外壳\n1.4操作系统结构\n1.4.1整体式系统\n1.4.2层次式系统\n1.4.3虚拟机\n1.4.4客户机\/服务器系统\n1.5本书其他部分的概要\n1.6小结\n习题\n第2章 进程\n2.1进程介绍\n2.1.2进程模型\n2.1.2进程的实现\n2.2进程间通信\n2.2.1竞争条件\n2.2.2临界区\n2.2.3忙等待的互斥\n2.2.4睡眠与唤醒\n2.2.5信号量\n2.2.6事件计数器\n2.2.7管程\n2.2.8消息传递\n2.2.9原语等价\n2.3经典的IPC问题\n2.3.1哲学家进餐问题\n2.3.2读者－写者问题\n2.3.3睡眠的理发师问题\n2.4进程调度\n2.4.1时间片轮转调度\n2.4.2优先级调度\n2.4.3多级队列\n2.4.4最短作业优先\n2.4.5保证调度算法\n2.4.6策略与机制\n2.4.7两级调度法\n2.5小结\n习题\n第3章 存储管理\n3.1无交换或分页的存储管理\n3.1.1无交换或分页的单道程序\n3.1.2多道程序设计和内存利用率\n3.1.3固定分区的多道程序\n3.2交换\n3.2.1可变分区的多道程序设计\n3.2.2使用位图的内存管理\n3.2.3使用链表的内存管理\n3.2.4伙伴式的内存管理\n3.2.5交换空间的分配\n3.2.6交换系统分析\n3.3虚拟存储器\n3.3.1分页\n3.3.2页表\n3.3.3分页硬件示例\n3.3.4相联存储器\n3.4页面置换算法\n3.4.1最优页面置换算法\n3.4.2最近未使用页面置换算法\n3.4.3先进先出页面置换算法\n3.4.4第二次机会页面置换算法\n3.4.5时钟页面置换算法\n3.4.6最久未使用页面置换算法\n3.4.7用软件模拟LRU\n3.5分页算法模型\n3.5.1Belady异常现象\n3.5.2栈式算法\n3.5.3距离字符串\n3.5.4缺页率预测\n3.6分页系统中的设计问题\n3.6.1工作集模型\n3.6.2局部与全局分配策略\n3.6.3页面尺寸\n3.6.4实现时涉及的问题\n3.7分段\n3.7.1纯分段系统的实现\n3.7.2分段和分页结合：MULTICS\n3.7.3分段和分页结合：Intel的386\n3.8小结\n习题\n第4章 文件系统\n4.1文件\n4.1.1文件命名\n4.1.2文件结构\n4.1.3文件类型\n4.1.4文件存取\n4.1.5文件属性\n4.1.6文件操作\n4.1.7存储映像文件\n4.2目录\n4.2.1层次目录系统\n4.2.2路径名\n4.2.3目录操作\n4.3文件系统的实现\n4.3.1实现文件\n4.3.2实现目录\n4.3.3共享目录\n4.3.4磁盘空间管理\n4.3.5文件系统的可靠性\n4.3.6文件系统性能\n4.4安全性\n4.4.1安全环境\n4.4.2著名的安全缺陷\n4.4.3Internet蠕虫\n4.4.4一般的安全性攻击\n4.4.5安全性的设计原则\n4.4.6用户验证\n4.5保护机制\n4.5.1保护域\n4.5.2存取控制表\n4.5.3权限\n4.5.4保护模型\n4.5.5隐藏通道\n4.6 小结\n习题\n第5章 I\/O设备管理\n5.1I\/O硬件组成原理\n5.1.1I\/O设备\n5.1.2设备控制器\n5.1.3直接存储器存取\n5.2I\/O软件原理\n5.2.1I\/O软件的目标\n5.2.2中断处理程序\n5.2.3设备驱动程序\n5.2.4与设备无关的I\/O软件\n5.2.5用户空间的I\/O软件\n5.3磁盘\n5.3.1磁盘硬件\n5.3.2磁盘调度算法\n5.3.3磁盘出错处理\n5.3.4“每次一道”高速缓冲\n5.3.5RAM盘\n5.4时钟\n5.4.1时钟硬件\n5.4.2时钟软件\n5.5终端\n5.5.1终端硬件\n5.5.2存储映像终端\n5.5.3输入软件\n5.5.4输出软件\n5.6小结\n习题\n第6章 死锁\n6.1资源\n6.2死锁定义\n6.2.1死锁的条件\n6.2.2死锁模型\n6.3鸵鸟算法\n6.4死锁检测和恢复\n6.4.1单种资源类型下的死锁检测\n6.4.2多种资源类型下的死锁检测\n6.4.3从死锁恢复\n6.5死锁避免\n6.5.1资源轨迹图\n6.5.2安全和不安全状态\n6.5.3单种资源的银行家算法\n6.5.4多种资源的银行家算法\n6.6死锁预防\n6.6.1破坏互斥条件\n6.6.2破坏占有和等待条件\n6.6.3破坏不可剥夺条件\n6.6.4破坏循环等待条件\n6.7其他问题\n6.7.1两阶段加锁\n6.7.2非资源死锁\n6.7.3饥饿\n6.8小结\n习题\n第7章 实例研究1：UNIX\n7.1UNIX的历史\n7.1.1UNICS\n7.1.2PDP－11UNIX\n7.1.3可移植的UNIX\n7.1.4伯克利UNIX\n7.1.5UNIX的标准化\n7.2UNIX概述\n7.2.1设计目标\n7.2.2接口\n7.2.3登录\n7.2.4shel1\n7.2.5文件和目录\n7.2.6应用程序\n7.3UNIX的一些基础概念\n7.3.1进程\n7.3.2内存管理模式\n7.3.3文件系统\n7.3.4I\/O设备\n7.4UNIX的系统调用\n7.4.1进程管理系统调用\n7.4.2内存管理系统调用\n7.4.3有关文件和目录的系统调用\n7.4.4I\/O系统调用\n7.5UNIX的实现\n7.5.1进程的实现\n7.5.2内存管理的实现\n7.5.3文件系统的实现\n7.5.4I\/O实现\n7.6 小结\n习题\n第8章 实例研究2：MS－DOS\n8.1MS－DOS的历史\n8.1.1IBMPC\n8.1.2MS－DOS1.0\n8.1.3MS－DOS2.0\n8.1.4MS－DOS3.0\n8.1.5MS.DOS4.0\n8.1.6MS－DOS5.0\n8.2MS－DOS概述\n8.2.1使用\n8.2.2shel1\n8.2.3配置\n8.3MS－DOS的基本概念\n8.3.1进程\n8.3.2内存模式\n8.3.3文件系统\n8.3.4I\/O设备\n8.4MS－DOS的系统调用\n8.4.1进程管理系统调用\n8.4.2内存管理系统调用\n8.4.3文件与目录系统调用\n8.4.4I\/O系统调用\n8.5MS－DOS的实现\n8.5.1进程的实现\n8.5.2内存管理的实现\n8.5.3文件系统的实现\n8.5.4I\/O的实现\n8.6小结\n习题\n第二部分 分布式操作系统\n第9章 分布式操作系统概述\n9.1目标\n9.1.1分布式系统相对于集中式系统的优点\n9.1.2分布式系统相对于独立PC机的优点\n9.1.3分布式系统的缺点\n9.2硬件上的概念\n9.2.1总线型多处理机\n9.2.2交换型多处理机\n9.2.3总线型多计算机\n9.2.4交换型多计算机\n9.3软件上的概念\n9.3.1网络操作系统和网络文件系统\n9.3.2真正的分布式系统\n9.3.3多处理机分时系统\n9.4设计上的考虑\n9.4.1透明性\n9.4.2灵活性\n9.4.3可靠性\n9.4.4性能\n9.4.5可扩展性\n9.5小结\n习题\n第10章 分布式系统中的通信问题\n10.1分层协议\n10.1.1物理层\n10.1.2数据链路层\n10.1.3网络层\n10.1.4传输层\n10.1.5会话层\n10.1.6表示层\n10.1.7应用层\n10.2客户－服务器模型\n10.2.1客户和服务器\n10.2.2一个客户和服务器的实例\n10.2.3寻址\n10.2.4阻塞与非阻塞原语\n10.2.5缓冲和非缓冲原语\n10.2.6可靠和不可靠原语\n10.2.7实现客户－服务器模型\n10.3远程过程调用\n10.3.1基本的RPC操作\n10.3.2参数传递\n10.3.3动态联编\n10.3.4出现差错时的RPC语义\n10.3.5与实现相关的论题\n10.3.6问题域\n10.4组通信\n10.4.1组通信入门\n10.4.2与设计有关的问题\n10.4.3ISIS中的组通信\n10.5小结\n习题\n第11章 分布式系统中的同步\n11.1时钟同步\n11.1.1逻辑时钟\n11.1.2物理时钟\n11.1.3时钟同步算法\n11.2互斥\n11.2.1集中式算法\n11.2.2分布式算法\n11.2.3令牌环算法\n11.2.4三种算法的比较\n11.3选举算法\n11.3.1Bully算法\n11.3.2环算法\n11.4原子事务\n11.4.1原子事务简介\n11.4.2事务模型\n11.4.3实现\n11.4.4并发控制\n11.5分布式系统中的死锁\n11.5.1分布式死锁的检测\n11.5.2分布式死锁的预防\n11.6小结\n习题\n第12章 分布式系统中的进程及处理器\n12.1线程\n12.1.1线程的引入\n12.1.2线程使用\n12.1.3线程包的设计问题\n12.1.4线程包的实现\n12.1.5线程和RPC\n12.1.6一个线程包的例\n12.2系统模型\n12.2.1工作站模型\n12.2.2使用空闲工作站\n12.2.3处理器池模型\n12.2.4混合模型\n12.3处理器分配\n12.3.1分配模型\n12.3.2处理器分配算法的设计原则\n12.3.3处理器分配算法的实现问题\n12.3.4处理器分配算法实例\n12.4分布式系统中的调度\n12.5小结\n习题\n第13章 分布式文件系统\n13.1 分布式文件系统设计\n13.1.1文件服务的接口\n13.1.2目录服务器接口\n13.1.3文件共享的语义\n13.2分布式文件系统的实现\n13.2.1文件的使用\n13.2.2系统结构\n13.2.3缓存区处理\n13.2.4复制性\n13.2.5例子：Andrew文件系统\n13.2.6经验教训\n13.3分布式文件系统的发展趋势\n13.3.1新的硬件\n13.3.2可伸缩性\n13.3.3广域网\n13.3.4移动用户\n13.3.5容错\n13.4 小结\n习题\n第14章 实例研究3： AMOEBA\n14.1Amoeba简介\n14.1.1Amoeba的历史\n14.1.2研究目的\n14.1.3Amoeba的体系结构\n14.1.4Amoeba微内核\n14.1.5Amoeba服务程序\n14.2Amoeba中的对象与权限字\n14.2.1权限字\n14.2.2对象的保护\n14.2.3标准操作\n14.3Amoeba中的进程管理\n14.3.1进程\n14.3.2线程\n14.4Amoeba的内存管理\n14.4.1段的管理\n14.4.2段的映像\n14.5Amoeba的通信\n14.5.1远程过程调用\n14.5.2Amoeba的组通信\n14.5.3快速局域网协议\n14.6Amoeba服务器\n14.6.1文件服务器\n14.6.2目录服务器\n14.6.3复制服务器\n14.6.4运行服务器\n14.6.5引导服务器\n14.6.6TCP\/IP服务器\n14.6.7其他服务器\n14.7小结\n习题\n第15章 实例研究4： Mach操作系统\n15.1概述\n15.1.1Mach的历史\n15.1.2Mach的设计目标\n15.1.3Mach的微内核\n15.1.4Mach的BSDUNIX服务器\n15.2Mach中的进程管理\n15.2.1进程\n15.2.2线程\n15.2.3调度\n15.3Mach的存储管理\n15.3.1虚拟存储\n15.3.2内存共享\n15.3.3外部存储管理器\n15.3.4Mach的分布式共享内存\n15.4MACH中的通信\n15.4.1端口\n15.4.2发送和接收消息\n15.4.3网络信息服务器\n15.5Mach中的BSDUNIX仿真\n15.6Amoeba与Mach的比较\n15.6.1基本原理\n15.6.2对象\n15.6.3进程\n15.6.4存储模式\n15.6.5通信\n15.6.6服务程序\n15.7小结\n习题\n附录A 阅读材料及参考文献\n附录B C语言简介\n",
      "pages": "501",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s9142891.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s9142891.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s9142891.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1054258\/",
      "id": "1054258",
      "publisher": "机械工业出版社",
      "isbn10": "7111071174",
      "isbn13": "9787111071174",
      "title": "现代操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1054258",
      "alt_title": "",
      "author_intro": "",
      "summary": "\n      ",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "40.00"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 1,
        "average": "0.0",
        "min": 0
      },
      "subtitle": "",
      "author": [],
      "pubdate": "2008-4",
      "tags": [],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s5888575.jpg",
      "binding": "",
      "translator": [],
      "catalog": "",
      "pages": "405",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s5888575.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s5888575.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s5888575.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/3039233\/",
      "id": "3039233",
      "publisher": "",
      "isbn10": "7121056585",
      "isbn13": "9787121056581",
      "title": "现代操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/3039233",
      "alt_title": "",
      "author_intro": "",
      "summary": "《高级学校规划教材•现代操作系统》是对传统的和现代的操作系统（OS）作了较为全面的介绍。《高级学校规划教材•现代操作系统》共分十七章：第1章为操作系统引论，介绍了OS的发展、传统的和现代的OS特征和功能。第2-4章深入地阐述了进程（线程）管理、进程同步、处理机调度和死锁；第5、6章对连续和离散存储器管理方式及虚拟存储器进行了介绍；第7章是自下而上地对I\/O系统的各个层次，作了较系统地阐述；第8、9章介绍了文件系统和磁盘存储器管理；第10章对用户接口，以及接口的实现方法做了介绍；从第11章开始到第15章，其内容都是与现代OS直接相关的。这几章的内容分别介绍多处理机OS、网络OS、多媒体OS和操作系统结构设计及系统安全性。第16、17章，介绍了一个OS实例Linux。",
      "price": "38.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 3,
        "average": "0.0",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "腾至阳"
      ],
      "pubdate": "2000-1",
      "tags": [
        {
          "count": 2,
          "name": "IT",
          "title": "IT"
        },
        {
          "count": 1,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 1,
          "name": "操作系统原理",
          "title": "操作系统原理"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s5684103.jpg",
      "binding": "787*1092",
      "translator": [],
      "catalog": "",
      "pages": "287",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s5684103.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s5684103.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s5684103.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1473322\/",
      "id": "1473322",
      "publisher": "北京蓝色畅想图书发行有限公司（原高等教育出版社）",
      "isbn10": "7040079291",
      "isbn13": "9787040079296",
      "title": "现代操作系统教程",
      "url": "https:\/\/api.douban.com\/v2\/book\/1473322",
      "alt_title": "",
      "author_intro": "",
      "summary": "本书把操作系统学科研究领域近年来的最新成果、主流操作系统的精华部分与传统教学内容有机融合，注重介绍该学科基本研究方法和基本发展规律。各章既有一般原理又有具体实例，既有传统内容又有新概念、新技术。",
      "price": "28.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 2,
        "average": "0.0",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "Andrew S.Tanenbaum",
        "Herbert Bos"
      ],
      "pubdate": "2017-11-1",
      "tags": [
        {
          "count": 5,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 3,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 2,
          "name": "计算机,操作系统",
          "title": "计算机,操作系统"
        },
        {
          "count": 2,
          "name": "教材",
          "title": "教材"
        },
        {
          "count": 1,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 1,
          "name": "m",
          "title": "m"
        }
      ],
      "origin_title": "Modern Operating Systems,Fourth Edition",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29674818.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "目录\n1 INTRODUCTION 1\n1.1 WHAT IS AN OPERATING SYSTEM 3\n1.1.1 The Operating System as an Extended Machine 4\n1.1.2 The Operating System as a Resource Manager 5\n1.2 HISTORY OF OPERATING SYSTEMS 6\n1.2.1 The First Generation （1945–55）： Vacuum Tubes 7\n1.2.2 The Second Generation （1955–65）： Transistors and Batch Systems 8\n1.2.3 The Third Generation （1965–1980）： ICs and Multiprogramming 9\n1.2.4 The Fourth Generation （1980–Present）： Personal Computers 14\n1.2.5 The Fifth Generation （1990–Present）： Mobile Computers 19\n1.3 COMPUTER HARDWARE REVIEW 20\n1.3.1 Processors 21\n1.3.2 Memory 24\n1.3.3 Disks 27\n1.3.4 I／O Devices 28\n1.3.5 Buses 31\n1.3.6 Booting the Computer 34\n1.4 THE OPERATING SYSTEM ZOO 35\n1.4.1 Mainframe Operating Systems 35\n1.4.2 Server Operating Systems 35\n1.4.3 Multiprocessor Operating Systems 36\n1.4.4 Personal Computer Operating Systems 36\n1.4.5 Handheld Computer Operating Systems 36\n1.4.6 Embedded Operating Systems 36\n1.4.7 Sensor—Node Operating Systems 37\n1.4.8 Real—Time Operating Systems 37\n1.4.9 Smart Card Operating Systems 38\n1.5 OPERATING SYSTEM CONCEPTS 38\n1.5.1 Processes 39\n1.5.2 Address Spaces 41\n1.5.3 Files 41\n1.5.4 Input／Output 45\n1.5.5 Protection 45\n1.5.6 The Shell 45\n1.5.7 Ontogeny Recapitulates Phylogeny 46\n1.6 SYSTEM CALLS 50\n1.6.1 System Calls for Process Management 53\n1.6.2 System Calls for File Management 56\n1.6.3 System Calls for Directory Management 57\n1.6.4 Miscellaneous System Calls 59\n1.6.5 The Windows Win32 API 60\n1.7 OPERATING SYSTEM STRUCTURE 62\n1.7.1 Monolithic Systems 62\n1.7.2 Layered Systems 63\n1.7.3 Microkernels 65\n1.7.4 Client—Server Model 68\n1.7.5 Virtual Machines 68\n1.7.6 Exokernels 72\n1.8 THE WORLD ACCORDING TO C 73\n1.8.1 The C Language 73\n1.8.2 Header Files 74\n1.8.3 Large Programming Projects 75\n1.8.4 The Model of Run Time 76\n1.9 RESEARCH ON OPERATING SYSTEMS 77\n1.10 OUTLINE OF THE REST OF THIS BOOK 78\n1.11 METRIC UNITS 79\n1.12 SUMMARY 80\n2 PROCESSES AND THREADS 85\n2.1 PROCESSES 85\n2.1.1 The Process Model 86\n2.1.2 Process Creation 88\n2.1.3 Process Termination 90\n2.1.4 Process Hierarchies 91\n2.1.5 Process States 92\n2.1.6 Implementation of Processes 94\n2.1.7 Modeling Multiprogramming 95\n2.2 THREADS 97\n2.2.1 Thread Usage 97\n2.2.2 The Classical Thread Model 102\n2.2.3 POSIX Threads 106\n2.2.4 Implementing Threads in User Space 108\n2.2.5 Implementing Threads in the Kernel 111\n2.2.6 Hybrid Implementations 112\n2.2.7 Scheduler Activations 113\n2.2.8 Pop—Up Threads 114\n2.2.9 Making Single—Threaded Code Multithreaded 115\n2.3 INTERPROCESS COMMUNICATION 119\n2.3.1 Race Conditions 119\n2.3.2 Critical Regions 121\n2.3.3 Mutual Exclusion with Busy Waiting 121\n2.3.4 Sleep and Wakeup 127\n2.3.5 Semaphores 130\n2.3.6 Mutexes 132\n2.3.7 Monitors 137\n2.3.8 Message Passing 144\n2.3.9 Barriers 146\n2.3.10 Avoiding Locks： Read—Copy—Update 148\n2.4 SCHEDULING 148\n2.4.1 Introduction to Scheduling 149\n2.4.2 Scheduling in Batch Systems 156\n2.4.3 Scheduling in Interactive Systems 158\n2.4.4 Scheduling in Real—Time Systems 164\n2.4.5 Policy Versus Mechanism 165\n2.4.6 Thread Scheduling 165\n2.5 CLASSICAL IPC PROBLEMS 167\n2.5.1 The Dining Philosophers Problem 167\n2.5.2 The Readers and Writers Problem 169\n2.6 RESEARCH ON PROCESSES AND THREADS 172\n2.7 SUMMARY 173\n3 MEMORY MANAGEMENT 181\n3.1 NO MEMORY ABSTRACTION 182\n3.2 A MEMORY ABSTRACTION： ADDRESS SPACES 185\n3.2.1 The Notion of an Address Space 185\n3.2.2 Swapping 187\n3.2.3 Managing Free Memory 190\n3.3 VIRTUAL MEMORY 194\n3.3.1 Paging 195\n3.3.2 Page Tables 198\n3.3.3 Speeding Up Paging 201\n3.3.4 Page Tables for Large Memories 205\n3.4 PAGE REPLACEMENT ALGORITHMS 209\n3.4.1 The Optimal Page Replacement Algorithm 209\n3.4.2 The Not Recently Used Page Replacement Algorithm 210\n3.4.3 The First—In， First—Out （FIFO） Page Replacement Algorithm 211\n3.4.4 The Second—Chance Page Replacement Algorithm 211\n3.4.5 The Clock Page Replacement Algorithm 212\n3.4.6 The Least Recently Used （LRU） Page Replacement Algorithm 213\n3.4.7 Simulating LRU in Software 214\n3.4.8 The Working Set Page Replacement Algorithm 215\n3.4.9 The WSClock Page Replacement Algorithm 219\n3.4.10 Summary of Page Replacement Algorithms 221\n3.5 DESIGN ISSUES FOR PAGING SYSTEMS 222\n3.5.1 Local versus Global Allocation Policies 222\n3.5.2 Load Control 225\n3.5.3 Page Size 225\n3.5.4 Separate Instruction and Data Spaces 227\n3.5.5 Shared Pages 228\n3.5.6 Shared Libraries 229\n3.5.7 Mapped Files 231\n3.5.8 Cleaning Policy 232\n3.5.9 Virtual Memory Interface 232\n3.6 IMPLEMENTATION ISSUES 233\n3.6.1 Operating System Involvement with Paging 233\n3.6.2 Page Fault Handling 234\n3.6.3 Instruction Backup 235\n3.6.4 Locking Pages in Memory 236\n3.6.5 Backing Store 237\n3.6.6 Separation of Policy and Mechanism 239\n3.7 SEGMENTATION 240\n3.7.1 Implementation of Pure Segmentation 243\n3.7.2 Segmentation with Paging： MULTICS 243\n3.7.3 Segmentation with Paging： The Intel x86247\n3.8 RESEARCH ON MEMORY MANAGEMENT 252\n3.9 SUMMARY 253\n4 FILE SYSTEMS 263\n4.1 FILES 265\n4.1.1 File Naming 265\n4.1.2 File Structure 267\n4.1.3 File Types 268\n4.1.4 File Access 269\n4.1.5 File Attributes 271\n4.1.6 File Operations 271\n4.1.7 An Example Program Using File—System Calls 273\n4.2 DIRECTORIES 276\n4.2.1 Single—Level Directory Systems 276\n4.2.2 Hierarchical Directory Systems 276\n4.2.3 Path Names 277\n4.2.4 Directory Operations 280\n4.3 FILE—SYSTEM IMPLEMENTATION 281\n4.3.1 File—System Layout 281\n4.3.2 Implementing Files 282\n4.3.3 Implementing Directories 287\n4.3.4 Shared Files 290\n4.3.5 Log—Structured File Systems 293\n4.3.6 Journaling File Systems 294\n4.3.7 Virtual File Systems 296\n4.4 FILE—SYSTEM MANAGEMENT AND OPTIMIZATION 299\n4.4.1 Disk—Space Management 299\n4.4.2 File—System Backups 306\n4.4.3 File—System Consistency 312\n4.4.4 File—System Performance 314\n4.4.5 Defragmenting Disks 319\n4.5 EXAMPLE FILE SYSTEMS 320\n4.5.1 The MS—DOS File System 320\n4.5.2 The UNIX V7 File System 323\n4.5.3 CD—ROM File Systems 325\n4.6 RESEARCH ON FILE SYSTEMS 331\n4.7 SUMMARY 332\n5 INPUT／OUTPUT 337\n5.1 PRINCIPLES OF I／O HARDWARE 337\n5.1.1 I／O Devices 338\n5.1.2 Device Controllers 339\n5.1.3 Memory—Mapped I／O 340\n5.1.4 Direct Memory Access 344\n5.1.5 Interrupts Revisited 347\n5.2 PRINCIPLES OF I／O SOFTWARE 351\n5.2.1 Goals of the I／O Software 351\n5.2.2 Programmed I／O 352\n5.2.3 Interrupt—Driven I／O 354\n5.2.4 I／O Using DMA 355\n5.3 I／O SOFTWARE LAYERS 356\n5.3.1 Interrupt Handlers 356\n5.3.2 Device Drivers 357\n5.3.3 Device—Independent I／O Software 361\n5.3.4 User—Space I／O Software 367\n5.4 DISKS 369\n5.4.1 Disk Hardware 369\n5.4.2 Disk Formatting 375\n5.4.3 Disk Arm Scheduling Algorithms 379\n5.4.4 Error Handling 382\n5.4.5 Stable Storage 385\n5.5 CLOCKS 388\n5.5.1 Clock Hardware 388\n5.5.2 Clock Software 389\n5.5.3 Soft Timers 392\n5.6 USER INTERFACES： KEYBOARD， MOUSE， MONITOR 394\n5.6.1 Input Software 394\n5.6.2 Output Software 399\n5.7 THIN CLIENTS 416\n5.8 POWER MANAGEMENT 417\n5.8.1 Hardware Issues 418\n5.8.2 Operating System Issues 419\n5.8.3 Application Program Issues 425\n5.9 RESEARCH ON INPUT／OUTPUT 426\n5.10 SUMMARY 428\n6 DEADLOCKS 435\n6.1 RESOURCES 436\n6.1.1 Preemptable and Nonpreemptable Resources 436\n6.1.2 Resource Acquisition 437\n6.2 INTRODUCTION TO DEADLOCKS 438\n6.2.1 Conditions for Resource Deadlocks 439\n6.2.2 Deadlock Modeling 440\n6.3 THE OSTRICH ALGORITHM 443\n6.4 DEADLOCK DETECTION AND RECOVERY 443\n6.4.1 Deadlock Detection with One Resource of Each Type 444\n6.4.2 Deadlock Detection with Multiple Resources of Each Type 446\n6.4.3 Recovery from Deadlock 448\n6.5 DEADLOCK AVOIDANCE 450\n6.5.1 Resource Trajectories 450\n6.5.2 Safe and Unsafe States 452\n6.5.3 The Banker’s Algorithm for a Single Resource 453\n6.5.4 The Banker’s Algorithm for Multiple Resources 454\n6.6 DEADLOCK PREVENTION 456\n6.6.1 Attacking the Mutual—Exclusion Condition 456\n6.6.2 Attacking the Hold—and—Wait Condition 456\n6.6.3 Attacking the No—Preemption Condition 457\n6.6.4 Attacking the Circular Wait Condition 457\n6.7 OTHER ISSUES 458\n6.7.1 Two—Phase Locking 458\n6.7.2 Communication Deadlocks 459\n6.7.3 Livelock 461\n6.7.4 Starvation 463\n6.8 RESEARCH ON DEADLOCKS 464\n6.9 SUMMARY 464\n7 VIRTUALIZATION AND THE CLOUD 471\n7.1 HISTORY 473\n7.2 REQUIREMENTS FOR VIRTUALIZATION 474\n7.3 TYPE 1 AND TYPE 2 HYPERVISORS 477\n7.4 TECHNIQUES FOR EFFICIENT VIRTUALIZATION 478\n7.4.1 Virtualizing the Unvirtualizable 479\n7.4.2 The Cost of Virtualization 482\n7.5 ARE HYPERVISORS MICROKERNELS DONE RIGHT 483\n7.6 MEMORY VIRTUALIZATION 486\n7.7 I／O VIRTUALIZATION 490\n7.8 VIRTUAL APPLIANCES 493\n7.9 VIRTUAL MACHINES ON MULTICORE CPUS 494\n7.10 LICENSING ISSUES 494\n7.11 CLOUDS 495\n7.11.1 Clouds as a Service 496\n7.11.2 Virtual Machine Migration 496\n7.11.3 Checkpointing 497\n7.12 CASE STUDY： VMWARE 498\n7.12.1 The Early History of VMware 498\n7.12.2 VMware Workstation 499\n7.12.3 Challenges in Bringing Virtualization to the x86500\n7.12.4 VMware Workstation： Solution Overview 502\n7.12.5 The Evolution of VMware Workstation 511\n7.12.6 ESX Server： VMware’s type 1 Hypervisor 512\n7.13 RESEARCH ON VIRTUALIZATION AND THE CLOUD 514\n8 MULTIPLE PROCESSOR SYSTEMS 517\n8.1 MULTIPROCESSORS 520\n8.1.1 Multiprocessor Hardware 520\n8.1.2 Multiprocessor Operating System Types 530\n8.1.3 Multiprocessor Synchronization 534\n8.1.4 Multiprocessor Scheduling 539\n8.2 MULTICOMPUTERS 544\n8.2.1 Multicomputer Hardware 545\n8.2.2 Low—Level Communication Software 550\n8.2.3 User—Level Communication Software 552\n8.2.4 Remote Procedure Call 556\n8.2.5 Distributed Shared Memory 558\n8.2.6 Multicomputer Scheduling 563\n8.2.7 Load Balancing 563\n8.3 DISTRIBUTED SYSTEMS 566\n8.3.1 Network Hardware 568\n8.3.2 Network Services and Protocols 571\n8.3.3 Document—Based Middleware 576\n8.3.4 File—System—Based Middleware 577\n8.3.5 Object—Based Middleware 582\n8.3.6 Coordination—Based Middleware 584\n8.4 RESEARCH ON MULTIPLE PROCESSOR SYSTEMS 587\n8.5 SUMMARY 588\n9 SECURITY 593\n9.1 THE SECURITY ENVIRONMENT 595\n9.1.1 Threats 596\n9.1.2 Attackers 598\n9.2 OPERATING SYSTEMS SECURITY 599\n9.2.1 Can We Build Secure Systems 600\n9.2.2 Trusted Computing Base 601\n9.3 CONTROLLING ACCESS TO RESOURCES 602\n9.3.1 Protection Domains 602\n9.3.2 Access Control Lists 605\n9.3.3 Capabilities 608\n9.4 FORMAL MODELS OF SECURE SYSTEMS 611\n9.4.1 Multilevel Security 612\n9.4.2 Covert Channels 615\n9.5 BASICS OF CRYPTOGRAPHY 619\n9.5.1 Secret—Key Cryptography 620\n9.5.2 Public—Key Cryptography 621\n9.5.3 One—Way Functions 622\n9.5.4 Digital Signatures 622\n9.5.5 Trusted Platform Modules 624\n9.6 AUTHENTICATION 626\n9.6.1 Authentication Using a Physical Object 633\n9.6.2 Authentication Using Biometrics 636\n9.7 EXPLOITING SOFTWARE 639\n9.7.1 Buffer Overflow Attacks 640\n9.7.2 Format String Attacks 649\n9.7.3 Dangling Pointers 652\n9.7.4 Null Pointer Dereference Attacks 653\n9.7.5 Integer Overflow Attacks 654\n9.7.6 Command Injection Attacks 655\n9.7.7 Time of Check to Time of Use Attacks 656\n9.8 INSIDER ATTACKS 657\n9.8.1 Logic Bombs 657\n9.8.2 Back Doors 658\n9.8.3 Login Spoofing 659\n9.9 MALWARE 660\n9.9.1 Trojan Horses 662\n9.9.2 Viruses 664\n9.9.3 Worms 674\n9.9.4 Spyware 676\n9.9.5 Rootkits 680\n9.10 DEFENSES 684\n9.10.1 Firewalls 685\n9.10.2 Antivirus and Anti—Antivirus Techniques 687\n9.10.3 Code Signing 693\n9.10.4 Jailing 694\n9.10.5 Model—Based Intrusion Detection 695\n9.10.6 Encapsulating Mobile Code 697\n9.10.7 Java Security 701\n9.11 RESEARCH ON SECURITY 703\n9.12 SUMMARY 704\n10 CASE STUDY 1： UNIX， LINUX， AND ANDROID 713\n10.1 HISTORY OF UNIX AND LINUX 714\n10.1.1 UNICS 714\n10.1.2 PDP—11 UNIX 715\n10.1.3 Portable UNIX 716\n10.1.4 Berkeley UNIX 717\n10.1.5 Standard UNIX 718\n10.1.6 MINIX 719\n10.1.7 Linux 720\n10.2 OVERVIEW OF LINUX 723\n10.2.1 Linux Goals 723\n10.2.2 Interfaces to Linux 724\n10.2.3 The Shell 725\n10.2.4 Linux Utility Programs 728\n10.2.5 Kernel Structure 730\n10.3 PROCESSES IN LINUX 733\n10.3.1 Fundamental Concepts 733\n10.3.2 Process—Management System Calls in Linux 735\n10.3.3 Implementation of Processes and Threads in Linux 739\n10.3.4 Scheduling in Linux 746\n10.3.5 Booting Linux 751\n10.4 MEMORY MANAGEMENT IN LINUX 753\n10.4.1 Fundamental Concepts 753\n10.4.2 Memory Management System Calls in Linux 756\n10.4.3 Implementation of Memory Management in Linux 758\n10.4.4 Paging in Linux 764\n10.5 INPUT／OUTPUT IN LINUX 767\n10.5.1 Fundamental Concepts 767\n10.5.2 Networking 769\n10.5.3 Input／Output System Calls in Linux 770\n10.5.4 Implementation of Input／Output in Linux 771\n10.5.5 Modules in Linux 774\n10.6 THE LINUX FILE SYSTEM 775\n10.6.1 Fundamental Concepts 775\n10.6.2 File—System Calls in Linux 780\n10.6.3 Implementation of the Linux File System 783\n10.6.4 NFS： The Network File System 792\n10.7 SECURITY IN LINUX 798\n10.7.1 Fundamental Concepts 798\n10.7.2 Security System Calls in Linux 800\n10.7.3 Implementation of Security in Linux 801\n10.8 ANDROID 802\n10.8.1 Android and Google 803\n10.8.2 History of Android 803\n10.8.3 Design Goals 807\n10.8.4 Android Architecture 809\n10.8.5 Linux Extensions 810\n10.8.6 Dalvik 814\n10.8.7 Binder IPC 815\n10.8.8 Android Applications 824\n10.8.9 Intents 836\n10.8.10 Application Sandboxes 837\n10.8.11 Security 838\n10.8.12 Process Model 844\n10.9 SUMMARY 848\n11 CASE STUDY 2： WINDOWS 8\n11.1 HISTORY OF WINDOWS THROUGH WINDOWS 8.1857\n11.1.11980s： MS—DOS 857\n11.1.21990s： MS—DOS—based Windows 859\n11.1.32000s： NT—based Windows 859\n11.1.4 Windows Vista 862\n11.1.52010s： Modern Windows 863\n11.2 PROGRAMMING WINDOWS 864\n11.2.1 The Native NT Application Programming Interface 867\n11.2.2 The Win32 Application Programming Interface 871\n11.2.3 The Windows Registry 875\n11.3 SYSTEM STRUCTURE 877\n11.3.1 Operating System Structure 877\n11.3.2 Booting Windows 893\n11.3.3 Implementation of the Object Manager 894\n11.3.4 Subsystems， DLLs， and User—Mode Services 905\n11.4 PROCESSES AND THREADS IN WINDOWS 908\n11.4.1 Fundamental Concepts 908\n11.4.2 Job， Process， Thread， and Fiber Management API Calls 914\n11.4.3 Implementation of Processes and Threads 919\n11.5 MEMORY MANAGEMENT 927\n11.5.1 Fundamental Concepts 927\n11.5.2 Memory—Management System Calls 931\n11.5.3 Implementation of Memory Management 932\n11.6 CACHING IN WINDOWS 942\n11.7 INPUT／OUTPUT IN WINDOWS 943\n11.7.1 Fundamental Concepts 944\n11.7.2 Input／Output API Calls 945\n11.7.3 Implementation of I／O 948\n11.8 THE WINDOWS NT FILE SYSTEM 952\n11.8.1 Fundamental Concepts 953\n11.8.2 Implementation of the NT File System 954\n11.9 WINDOWS POWER MANAGEMENT 964\n11.10 SECURITY IN WINDOWS 8966\n11.10.1 Fundamental Concepts 967\n11.10.2 Security API Calls 969\n11.10.3 Implementation of Security 970\n11.10.4 Security Mitigations 972\n11.11 SUMMARY 975\n12 OPERATING SYSTEM DESIGN 981\n12.1 THE NATURE OF THE DESIGN PROBLEM 982\n12.1.1 Goals 982\n12.1.2 Why Is It Hard to Design an Operating System 983\n12.2 INTERFACE DESIGN 985\n12.2.1 Guiding Principles 985\n12.2.2 Paradigms 987\n12.2.3 The System—Call Interface 991\n12.3 IMPLEMENTATION 993\n12.3.1 System Structure 993\n12.3.2 Mechanism vs.Policy 997\n12.3.3 Orthogonality 998\n12.3.4 Naming 999\n12.3.5 Binding Time 1001\n12.3.6 Static vs.Dynamic Structures 1001\n12.3.7 Top—Down vs.Bottom—Up Implementation 1003\n12.3.8 Synchronous vs.Asynchronous Communication 1004\n12.3.9 Useful Techniques 1005\n12.4 PERFORMANCE 1010\n12.4.1 Why Are Operating Systems Slow 1010\n12.4.2 What Should Be Optimized 1011\n12.4.3 Space—Time Trade—offs 1012\n12.4.4 Caching 1015\n12.4.5 Hints 1016\n12.4.6 Exploiting Locality 1016\n12.4.7 Optimize the Common Case 1017\n12.5 PROJECT MANAGEMENT 1018\n12.5.1 The Mythical Man Month 1018\n12.5.2 Team Structure 1019\n12.5.3 The Role of Experience 1021\n12.5.4 No Silver Bullet 1021\n12.6 TRENDS IN OPERATING SYSTEM DESIGN 1022\n12.6.1 Virtualization and the Cloud 1023\n12.6.2 Manycore Chips 1023\n12.6.3 Large—Address—Space Operating Systems 1024\n12.6.4 Seamless Data Access 1025\n12.6.5 Battery—Powered Computers 1025\n12.6.6 Embedded Systems 1026\n12.7 SUMMARY 1027\n13 READING LIST AND BIBLIOGRAPHY 1031\n13.1 SUGGESTIONS FOR FURTHER READING 1031\n13.1.1 Introduction 1031\n13.1.2 Processes and Threads 1032\n13.1.3 Memory Management 1033\n13.1.4 File Systems 1033\n13.1.5 Input／Output 1034\n13.1.6 Deadlocks 1035\n13.1.7 Virtualization and the Cloud 1035\n13.1.8 Multiple Processor Systems 1036\n13.1.9 Security 1037\n13.1.10 Case Study 1： UNIX， Linux， and Android 1039\n13.1.11 Case Study 2： Windows 81040\n13.1.12 Operating System Design 1040\n13.2 ALPHABETICAL BIBLIOGRAPHY 1041\nINDEX 1071",
      "pages": "1070",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s29674818.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s29674818.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29674818.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/30124664\/",
      "id": "30124664",
      "publisher": "机械工业出版社",
      "isbn10": "7111581652",
      "isbn13": "9787111581659",
      "title": "现代操作系统(英文版)(第4版)",
      "url": "https:\/\/api.douban.com\/v2\/book\/30124664",
      "alt_title": "Modern Operating Systems,Fourth Edition",
      "author_intro": "作者：（荷兰）安德鲁 S.塔嫩鲍姆（Andrew S.Tanenbaum） （荷兰）赫伯特·博斯（Herbert Bos）\n安德鲁 S.塔嫩鲍姆（Andrew S.Tanenbaum），阿姆斯特丹自由大学教授。荷兰皇家艺术与科学院教授。他撰写的计算机教材享誉全球，被翻译为20种语言在各国大学中使用。他开发的MINIX操作系统是一个开源项目，专注于高可靠性、灵活性及安全性。他曾赢得享有盛名的欧洲研究理事会卓越贡献奖，以及ACM和IEEE的诸多奖项。\n赫伯特·博斯（Herbert Bos），阿姆斯特丹自由大学教授。他是一名全方位的系统专家。尤其是在安全和UNIX方面。目前致力于系统与网络安全领域的研究，2011年因在恶意软件反向工程方面的贡献而获得ERC奖。",
      "summary": "《现代操作系统(英文版)(第4版)》是操作系统领域的经典教材，主要内容包括进程与线程、内存管理、文件系统、输入／输出、死锁、虚拟化和云、多处理机系统、安全，以及关于UNIX、Linux、Android和Windows的实例研究等。第4版对知识点进行了全面更新，反映了当代操作系统的发展与动向。《现代操作系统(英文版)(第4版)》适合作为高等院校计算机专业的操作系统课程教材，也适合相关技术人员参考。",
      "series": {
        "id": "1895",
        "title": "经典原版书库"
      },
      "price": "120.9"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 267,
        "average": "8.2",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[日] 川合秀实"
      ],
      "pubdate": "2012-8",
      "tags": [
        {
          "count": 1000,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 515,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 332,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 261,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 155,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 120,
          "name": "计算机技术",
          "title": "计算机技术"
        },
        {
          "count": 115,
          "name": "汇编语言",
          "title": "汇编语言"
        },
        {
          "count": 106,
          "name": "自制",
          "title": "自制"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s11138117.jpg",
      "binding": "平装",
      "translator": [
        "周自恒",
        "李黎明",
        "曾祥江",
        "张文旭"
      ],
      "catalog": "目 　 　录\n第0天 　着手开发之前　　1\n1 　前言　　1\n2 　何谓操作系统　　3\n3 　开发操作系统的各种方法　　4\n4 　无知则无畏　　4\n5 　如何开发操作系统　　6\n6 　操作系统开发中的困难　　7\n7 　学习本书时的注意事项（重要！）　　9\n8 　各章内容摘要　　11\n第1天 　从计算机结构到汇编程序入门　　13\n1 　先动手操作　　13\n2 　究竟做了些什么　　19\n3 　初次体验汇编程序　　22\n4 　加工润色　　24\n第2天 　汇编语言学习与Makefile入门　　28\n1 　介绍文本编辑器　　28\n2 　继续开发　　29\n3 　先制作启动区　　40\n4 　Makefile入门　　41\n第3天 　进入32位模式并导入C语言　　45\n1 　制作真正的IPL　　45\n2 　试错　　50\n3 　读到18扇区　　51\n4 　读入10个柱面　　52\n5 　着手开发操作系统　　54\n6 　从启动区执行操作系统　　55\n7 　确认操作系统的执行情况　　56\n8 　32位模式前期准备　　57\n9 　开始导入C语言　　59\n10 　实现HLT（harib00j）　　62\n第4天 　C语言与画面显示的练习　　64\n1 　用C语言实现内存写入（harib01a）　　64\n2 　条纹图案（harib01b）　　67\n3 　挑战指针（harib01c）　　69\n4 　指针的应用（1）（harib01d）　　74\n5 　指针的应用（2）（harib01e）　　74\n6 　色号设定（harib01f）　　75\n7 　绘制矩形（harib01g）　　84\n8 　今天的成果（harib01h）　　86\n第5天 　结构体、文字显示与GDT\/IDT初始化　　88\n1 　接收启动信息（harib02a）　　88\n2 　试用结构体（harib02b）　　89\n3 　试用箭头记号（harib02c）　　91\n4 　显示字符（harib02d）　　91\n5 　增加字体（harib02e）　　94\n6 　显示字符串（harib02f）　　96\n7 　显示变量值（harib02g）　　97\n8 　显示鼠标指针（harib02h）　　99\n9 　GDT与IDT的初始化（harib02i）　　101\n第6天 　分割编译与中断处理　　108\n1 　分割源文件（harib03a）　　108\n2 　整理Makefile（harib03b）　　109\n3 　整理头文件（harib03c）　　110\n4 　意犹未尽　　112\n5 　初始化PIC（harib03d）　　115\n6 　中断处理程序的制作（harib03e）　　119\n第7天 　FIFO与鼠标控制　　125\n1 　获取按键编码（hiarib04a）　　125\n2 　加快中断处理（hiarib04b）　　127\n3 　制作FIFO缓冲区（hiarib04c）　　130\n4 　改善FIFO缓冲区（hiarib04d）　　133\n5 　整理FIFO缓冲区（hiarib04e）　　135\n6 　总算讲到鼠标了（harib04f）　　138\n7 　从鼠标接受数据（harib04g）　　141\n第8天 　鼠标控制与32位模式切换　　144\n1 　鼠标解读（1）（harib05a）　　144\n2 　稍事整理（harib05b）　　146\n3 　鼠标解读（2）（harib05c）　　148\n4 　移动鼠标指针（harib05d）　　151\n5 　通往32位模式之路　　153\n第9天 　内存管理　　162\n1 　整理源文件（harib06a）　　162\n2 　内存容量检查（1）（harib06b）　　163\n3 　内存容量检查（2）（harib06c）　　168\n4 　挑战内存管理（harib06d）　　172\n第10天 　叠加处理　　181\n1 　内存管理（续）（harib07a）　　181\n2 　叠加处理（harib07b）　　184\n3 　提高叠加处理速度（1）（harib07c）　　194\n4 　提高叠加处理速度（2）（harib07d）　　197\n第11天 　制作窗口　　201\n1 　鼠标显示问题（harib08a）　　201\n2 　实现画面外的支持（harib08b）　　202\n3 　shtctl的指定省略（harib08c）　　203\n4 　显示窗口（harib08d）　　206\n5 　小实验（harib08e）　　208\n6 　高速计数器（harib08f）　　209\n7 　消除闪烁（1）（harib08g）　　211\n8 　消除闪烁（2）（harib08h）　　214\n第12天 　定时器（1）　　220\n1 　使用定时器（harib09a）　　220\n2 　计量时间（harib09b）　　224\n3 　超时功能（harib09c）　　225\n4 　设定多个定时器（harib09d）　　228\n5 　加快中断处理（1）（harib09e）　　232\n6 　加快中断处理（2）（harib09f）　　234\n7 　加快中断处理（3）（harib09g）　　236\n第13天 　定时器（2）　　240\n1 　简化字符串显示（harib10a）　　240\n2 　重新调整FIFO缓冲区（1）（harib10b）　　241\n3 　测试性能（harib10c～harib10f）　　243\n4 　重新调整FIFO缓冲区（2）（harib10g）　　246\n5 　加快中断处理（4）（harib10h）　　253\n6 　使用“哨兵”简化程序（harib10i）　　257\n第14天 　高分辨率及键盘输入　　262\n1 　继续测试性能（harib11a～harib11c）　　262\n2 　提高分辨率（1）（harib11d）　　266\n3 　提高分辨率（2）（harib11e）　　269\n4 　键盘输入（1）（harib11f）　　272\n5 　键盘输入（2）（harib11g）　　275\n6 　追记内容（1）（harib11h）　　277\n7 　追记内容（2）（harib11i）　　279\n第15天 　多任务（1）　　282\n1 　挑战任务切换（harib12a）　　282\n2 　任务切换进阶（harib12b）　　289\n3 　做个简单的多任务（1）（harib12c）　　291\n4 　做个简单的多任务（2）（harib12d）　　293\n5 　提高运行速度（harib12e）　　294\n6 　测试运行速度（harib12f）　　297\n7 　多任务进阶（harib12g）　　299\n第16天 　多任务（2）　　304\n1 　任务管理自动化（harib13a）　　304\n2 　让任务休眠（harib13b）　　308\n3 　增加窗口数量（harib13c）　　313\n4 　设定任务优先级（1）（harib13d）　　317\n5 　设定任务优先级（2）（harib13e）　　320\n第17天 　命令行窗口　　329\n1 　闲置任务（harib14a）　　329\n2 　创建命令行窗口（harib14b）　　331\n3 　切换输入窗口（harib14c）　　334\n4 　实现字符输入（harib14d）　　337\n5 　符号的输入（harib14e）　　341\n6 　大写字母与小写字母（harib14f）　　343\n7 　对各种锁定键的支持（harib14g）　　346\n第18天 　dir命令　　350\n1 　控制光标闪烁（1）（harib15a）　　350\n2 　控制光标闪烁（2）（harib15b）　　352\n3 　对回车键的支持（harib15c）　　355\n4 　对窗口滚动的支持（harib15d）　　357\n5 　mem命令（harib15e）　　359\n6 　cls命令（harib15f）　　363\n7 　dir命令（harib15g）　　366\n第19天 　应用程序　　371\n1 　type命令（harib16a）　　371\n2 　type命令改良（harib16b）　　378\n3 　对FAT的支持（harib16c）　　382\n4 　代码整理（harib16d）　　387\n5 　第一个应用程序（harib16e）　　387\n第20天 　API　　392\n1 　程序整理（harib17a）　　392\n2 　显示单个字符的API（1）（harib17b）　　399\n3 　显示单个字符的API（2）（harib17c）　　402\n4 　结束应用程序（harib17d）　　403\n5 　不随操作系统版本而改变的API（harib17e）　　405\n6 　为应用程序自由命名（harib17f）　　408\n7 　当心寄存器（harib17g）　　410\n8 　用API显示字符串（harib17h）　　412\n第21天 　保护操作系统　　418\n1 　攻克难题——字符串显示API（harib18a）　　418\n2 　用C语言编写应用程序（harib18b）　　420\n3 　保护操作系统（1）（harib18c）　　424\n4 　保护操作系统（2）（harib18d）　　426\n5 　对异常的支持（harib18e）　　431\n6 　保护操作系统（3）（harib18f）　　434\n7 　保护操作系统（4）（harib18g）　　435\n第22天 　用C语言编写应用程序　　443\n1 　保护操作系统（5）（harib19a）　　443\n2 　帮助发现bug（harib19b）　　448\n3 　强制结束应用程序（harib19c）　　452\n4 　用C语言显示字符串（1）（harib19d）　　455\n5 　用C语言显示字符串（2）（harib19e）　　457\n6 　显示窗口（harib19f）　　462\n7 　在窗口中描绘字符和方块（harib19g）　　465\n第23天 　图形处理相关　　468\n1 　编写malloc（harib20a）　　468\n2 　画点（harib20b）　　472\n3 　刷新窗口（harib20c）　　475\n4 　画直线（harib20d）　　478\n5 　关闭窗口（harib20e）　　483\n6 　键盘输入API（harib20f）　　484\n7 　用键盘输入来消遣一下（harib20g）　　488\n8 　强制结束并关闭窗口（harib20h）　　489\n第24天 　窗口操作　　493\n1 　窗口切换（1）（harib21a）　　493\n2 　窗口切换（2）（harib21b）　　495\n3 　移动窗口（harib21c）　　496\n4 　用鼠标关闭窗口（harib21d）　　498\n5 　将输入切换到应用程序窗口（harib21e）　　500\n6 　用鼠标切换输入窗口（harib21f）　　506\n7 　定时器API（harib21g）　　507\n8 　取消定时器（harib21h）　　511\n第25天 　增加命令行窗口　　515\n1 　蜂鸣器发声（harib22a）　　515\n2 　增加更多的颜色（1）（harib22b）　　518\n3 　增加更多的颜色（2）（harib22c）　　520\n4 　窗口初始位置（harib22d）　　523\n5 　增加命令行窗口（1）（harib22e）　　524\n6 　增加命令行窗口（2）（harib22f）　　528\n7 　增加命令行窗口（3）（harib22g）　　531\n8 　增加命令行窗口（4）（harib22h）　　532\n9 　变得更像真正的操作系统（1）（harib22i）　　534\n10 　变得更像真正的操作系统（2）（harib22j）　　538\n第26天 　为窗口移动提速　　541\n1 　提高窗口移动速度（1）（harib23a）　　541\n2 　提高窗口移动速度（2）（harib23b）　　543\n3 　提高窗口移动速度（3）（harib23c）　　547\n4 　提高窗口移动速度（4）（harib23d）　　549\n5 　启动时只打开一个命令行窗口（harib23e）　　551\n6 　增加更多的命令行窗口（harib23f）　　554\n7 　关闭命令行窗口（1）（harib23g）　　555\n8 　关闭命令行窗口（2）（harib23h）　　561\n9 　start命令（harib23i）　　563\n10 　ncst命令（harib23j）　　564\n第27天 　LDT与库　　571\n1 　先来修复bug（harib24a）　　571\n2 　应用程序运行时关闭命令行窗口（harib24b）　　573\n3 　保护应用程序（1）（harib24c）　　577\n4 　保护应用程序（2）（harib24d）　　580\n5 　优化应用程序的大小（harib24e）　　583\n6 　库（harib24f）　　587\n7 　整理make环境（harib24g）　　590\n第28天 　文件操作与文字显示　　598\n1 　alloca（1）（harib25a）　　598\n2 　alloca（2）（harib25b）　　601\n3 　文件操作API（harib25c）　　605\n4 　命令行API（harib25d）　　612\n5 　日文文字显示（1）（harib25e）　　615\n6 　日文文字显示（2）（harib25f）　　624\n7 　日文文字显示（3）（harib25g）　　629\n第29天 　压缩与简单的应用程序　　635\n1 　修复bug（harib26a）　　635\n2 　文件压缩（harib26b）　　636\n3 　标准函数　　644\n4 　非矩形窗口（harib26c）　　647\n5 　bball（harib26d）　　648\n6 　外星人游戏（harib26e）　　651\n第30天 　高级的应用程序　　659\n1 　命令行计算器（harib27a）　　659\n2 　文本阅览器（harib27b）　　664\n3 　MML播放器（harib27c）　　671\n4 　图片阅览器（harib27d）　　679\n5 　IPL的改良（harib27e）　　683\n6 　光盘启动（harib27f）　　688\n第31天 　写在开发完成之后　　690\n1 　继续开发要靠大家的努力　　690\n2 　关于操作系统的大小　　692\n3 　操作系统开发的诀窍　　693\n4 　分享给他人使用　　694\n5 　关于光盘中的软件　　695\n6 　关于开源的建议　　696\n7 　后记　　698\n8 　毕业典礼　　703\n9 　附录　　704\n",
      "pages": "704",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s11138117.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s11138117.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s11138117.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/11530329\/",
      "id": "11530329",
      "publisher": "人民邮电出版社",
      "isbn10": "7115287961",
      "isbn13": "9787115287960",
      "title": "30天自制操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/11530329",
      "alt_title": "",
      "author_intro": "川合秀实（Hidemi Kawai）\n生于1975年，是一位以“轻量化”编程思想见长的“非主流”开发者。2000年因自行开发的OSASK项目而名声大噪。OSASK是一个开源的32位微型操作系统，它并非以Linux等内核为基础，而是完全从零开始开发，在一张软盘的容量下实现了GUI、多任务、多语言等高级特性，启动时间只需1秒。本书的内容可以看成是作者以OSASK为蓝本，教会读者从零开始开发一个操作系统，同时可以让初学者在编写操作系统的过程中，了解操作系统背后更多的知识。",
      "summary": "自己编写一个操作系统，是许多程序员的梦想。也许有人曾经挑战过，但因为太难而放弃了。其实你错了，你的失败并不是因为编写操作系统太难，而是因为没有人告诉你那其实是一件很简单的事。那么，你想不想再挑战一次呢？\n这是一本兼具趣味性、实用性与学习性的书籍。作者从计算机的构造、汇编语言、C语言开始解说，让你在实践中掌握算法。在这本书的指导下，从零编写所有代码，30天后就可以制作出一个具有窗口系统的32位多任务操作系统。\n本书以课题为主导，边做边玩，抛开晦涩难懂的语言，行文风格十分随性，还充满了各种欢乐的吐槽，适合操作系统爱好者和程序设计人员阅读。",
      "series": {
        "id": "34137",
        "title": "自制系列"
      },
      "price": "99.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 579,
        "average": "8.7",
        "min": 0
      },
      "subtitle": "升级你的操作系统",
      "author": [
        "李笑来"
      ],
      "pubdate": "2016-2",
      "tags": [
        {
          "count": 268,
          "name": "时间管理",
          "title": "时间管理"
        },
        {
          "count": 258,
          "name": "自我管理",
          "title": "自我管理"
        },
        {
          "count": 186,
          "name": "李笑来",
          "title": "李笑来"
        },
        {
          "count": 128,
          "name": "罗辑思维",
          "title": "罗辑思维"
        },
        {
          "count": 125,
          "name": "成长",
          "title": "成长"
        },
        {
          "count": 120,
          "name": "思维",
          "title": "思维"
        },
        {
          "count": 109,
          "name": "方法论",
          "title": "方法论"
        },
        {
          "count": 108,
          "name": "效率",
          "title": "效率"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28378989.jpg",
      "binding": "精装",
      "translator": [],
      "catalog": "第0章   困境  \/ 001\n1. 问题 \/ 002\n2. 慌乱 \/ 005\n3. 解决 \/ 008\n第1章   醒悟  \/ 013\n1. 孰主孰仆 \/ 014\n2. 何谓心智 \/ 018\n3. 我的案例 \/ 020\n第2章   现实  \/ 029\n1. 速成绝无可能 \/ 030\n2. 交换才是硬道理 \/ 034\n3. 完美永不存在 \/ 037\n4. 未知永远存在 \/ 040\n5. 现状无法马上摆脱 \/ 044\n6. 与时间做朋友 \/ 047\n第3章   管理 \/ 053\n1. 估算时间 \/ 054\n2. 及时行动 \/ 058\n3. 直面困难 \/ 061\n4. 关注步骤 \/ 064\n5. 并行串行 \/ 068\n6. 感知时间 \/ 073\n7. 记录开销 \/ 081\n8. 制订预算 \/ 083\n9. 计划 \/ 087\n10. 列表 \/ 095\n11. 流程 \/ 101\n12. 预演 \/ 106\n13. 验收 \/ 109\n第4章   学习 \/ 113\n1. 效率本质 \/ 114\n2. 基本途径 \/ 117\n3. 主要手段 \/ 123\n4. 经验局限 \/ 128\n5. 自学能力 \/ 136\n第5章   思考 \/ 145\n1. 勤于思考 \/ 146\n2. 思维陷阱 \/ 151\n3. 因果关系 \/ 156\n4. 相关命题 \/ 166\n5. 举证责任 \/ 169\n6. 案例局限 \/ 173\n7. 对立论证 \/ 176\n8. 张冠李戴 \/ 179\n9. 辨析感悟 \/ 182\n10. 克服恐惧 \/ 188\n11. 辅助工具 \/ 191\n第6章   交流 \/ 199\n1. 学会倾听 \/ 200\n2. 说与不说 \/ 209\n3. 交流守则 \/ 212\n4. 正确复述 \/ 220\n5. 勤于反思 \/ 223\n第7章   应用 \/ 229\n1. 兴趣 \/ 230\n2. 方法 \/ 232\n3. 痛苦 \/ 236\n4. 比较 \/ 243\n5. 运气 \/ 246\n6. 人脉 \/ 250\n7. 自卑 \/ 258\n8. 灵感 \/ 265\n9. 鼓励 \/ 272\n10. 效率 \/ 275\n11. 节奏 \/ 281\n12. 物极必反 \/ 285\n13. 自我证明 \/ 290\n第8章   积累 \/ 295\n1. 坚信积累 \/ 296\n2. 越早越好 \/ 303\n3. 如何开始 \/ 310\n4. 躺着赚钱 \/ 314\n5. 自由意志 \/ 318\n6. 生活目标 \/ 325\n7. 注重学识 \/ 330\n8. 节省与否 \/ 335\n9. 人丑就要多读书 \/ 339\n10. 被动支出 \/ 342\n11. 认识周期 \/ 349\n12. 性格养成 \/ 355\n13. 别做“险盲” \/ 358\n附录 \/ 363\n第1版推荐序 \/ 364\n主要参考文献\/ 370\n致谢\/ 372",
      "pages": "372",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s28378989.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s28378989.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s28378989.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/26704143\/",
      "id": "26704143",
      "publisher": "电子工业出版社",
      "isbn10": "712127941X",
      "isbn13": "9787121279416",
      "title": "把时间当作朋友(罗辑思维独家定制版)",
      "url": "https:\/\/api.douban.com\/v2\/book\/26704143",
      "alt_title": "",
      "author_intro": "",
      "summary": "为什么你总是说“没有时间了”，勤奋而又懒惰？最节省时间的方式是学习，为什么你砍柴而不肯磨刀？基于过程的记录，为什么迥异于基于结果的记录？一个人对时间的精确感知能力真的能训练得像特异功能？都是平凡人，为什么若干年后彼此已成天壤之别？时间这条船，为什么只送心智成熟的人去往梦想的彼岸？绝大多数的成功根本与智商没有任何关系，所有的失败都与且只与时间限制有关。当你把时间花费到一个人身上的时候，相当于在他的身上倾注了你生命的一段，哪管最终的结果如何，反正，那个人那件事都成了你生命中的一部分，不管最后你喜欢还是不喜欢。",
      "series": {
        "id": "31040",
        "title": "罗辑思维独家定制版"
      },
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 401,
        "average": "8.7",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "于渊"
      ],
      "pubdate": "2009-6",
      "tags": [
        {
          "count": 805,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 314,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 267,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 190,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 178,
          "name": "底层",
          "title": "底层"
        },
        {
          "count": 122,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 69,
          "name": "开发",
          "title": "开发"
        },
        {
          "count": 66,
          "name": "programming",
          "title": "programming"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3788445.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "",
      "pages": "469",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s3788445.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s3788445.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s3788445.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/3735649\/",
      "id": "3735649",
      "publisher": "电子工业出版社",
      "isbn10": "7121084422",
      "isbn13": "9787121084423",
      "title": "Orange'S:一个操作系统的实现",
      "url": "https:\/\/api.douban.com\/v2\/book\/3735649",
      "alt_title": "",
      "author_intro": "",
      "summary": "《Orange S:一个操作系统的实现》从只有二十行的引导扇区代码出发，一步一步地向读者呈现一个操作系统框架的完成过程。书中不仅关注代码本身，同时关注完成这些代码的思路和过程。本书不同于其他的理论型书籍，而是提供给读者一个动手实践的路线图。读者可以根据路线图逐步完成各部分的功能，从而避免了一开始就面对整个操作系统数万行代码时的迷茫和挫败感。书中讲解了大量在开发操作系统中需注意的细节问题，这些细节不仅能使读者更深刻地认识操作系统的核心原理，而且使整个开发过程少走弯路。本书分上下两篇，共11章。其中每一章都以前一章的工作成果为基础，实现一项新的功能。而在章的内部，一项大的功能被分解成许多小的步骤，通过完成每个小的步骤，读者可以不断获得阶段性的成果，从而让整个开发过程变得轻松并且有趣。\n本书适合各类程序员、程序开发爱好者阅读，也可作为高等院校操作系统课程的实践参考书。",
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 173,
        "average": "8.8",
        "min": 0
      },
      "subtitle": "精髓与设计原理（原书第6版）",
      "author": [
        "William Stallings"
      ],
      "pubdate": "2010.9",
      "tags": [
        {
          "count": 312,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 129,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 117,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 49,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 46,
          "name": "经典",
          "title": "经典"
        },
        {
          "count": 30,
          "name": "计算机技术",
          "title": "计算机技术"
        },
        {
          "count": 30,
          "name": "ComputerSystem",
          "title": "ComputerSystem"
        },
        {
          "count": 28,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "Operating Systems: Internals and Design Principles, Sixth Edition",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s4450637.jpg",
      "binding": "平装",
      "translator": [
        "陈向群",
        "陈渝"
      ],
      "catalog": "出版者的话\n译者序\n前言\n第0章  读者指南\t1\n0.1  本书概述\t1\n0.2  读者和教师的学习路线图\t1\n0.3  Internet和Web资源\t2\n第一部分  背景\n第1章  计算机系统概述\t6\n1.1  基本构成\t6\n1.2  处理器寄存器\t6\n1.2.1  用户可见寄存器\t7\n1.2.2  控制和状态寄存器\t8\n1.3  指令的执行\t9\n1.3.1  取指令和执行指令\t9\n1.3.2  I\/O函数\t11\n1.4  中断\t11\n1.4.1  中断和指令周期\t12\n1.4.2  中断处理\t14\n1.4.3  多个中断\t15\n1.4.4  多道程序设计\t17\n1.5  存储器的层次结构\t17\n1.6  高速缓存\t20\n1.6.1  动机\t20\n1.6.2  高速缓存原理\t20\n1.6.3  高速缓存设计\t21\n1.7  I\/O通信技术\t22\n1.7.1  可编程I\/O\t22\n1.7.2  中断驱动I\/O\t22\n1.7.3  直接内存存取\t24\n1.8  推荐读物和网站\t24\n1.9  关键术语、复习题和习题\t25\n附录1A  两级存储器的性能特征\t27\n附录1B  过程控制\t30\n第2章  操作系统概述\t33\n2.1  操作系统的目标和功能\t33\n2.1.1  作为用户\/计算机接口的\n2.1.1  操作系统\t33\n2.1.2  作为资源管理器的操作\n2.1.1  系统\t34\n2.1.3  操作系统的易扩展性\t35\n2.2  操作系统的发展\t35\n2.2.1  串行处理\t35\n2.2.2  简单批处理系统\t36\n2.2.3  多道程序设计批处理系统\t38\n2.2.4  分时系统\t40\n2.3  主要的成就\t42\n2.3.1  进程\t42\n2.3.2  内存管理\t44\n2.3.3  信息保护和安全\t46\n2.3.4  调度和资源管理\t46\n2.3.5  系统结构\t47\n2.4  现代操作系统的特征\t49\n2.5  微软的Windows 概述\t51\n2.5.1  历史\t51\n2.5.2  单用户多任务\t53\n2.5.3  体系结构\t53\n2.5.4  客户\/服务器模型\t56\n2.5.5  线程和SMP\t57\n2.5.6  Windows对象\t57\n2.6  传统的UNIX系统\t58\n2.6.1  历史\t58\n2.6.2  描述\t59\n2.7  现代UNIX系统\t60\n2.7.1  系统V版本4（SVR4）\t60\n2.7.2  BSD\t61\n2.7.3  Solaris 10\t61\n2.8  Linux操作系统\t61\n2.8.1  历史\t62\n2.8.2  模块结构\t63\n2.8.3  内核组件\t64\n2.9  推荐读物和网站\t67\n2.10  关键术语、复习题和习题\t68\n第二部分  进程\n第3章  进程描述和控制\t73\n3.1  什么是进程\t73\n3.1.1  背景\t73\n3.1.2  进程和进程控制块\t74\n3.2  进程状态\t75\n3.2.1  两状态进程模型\t76\n3.2.2  进程的创建和终止\t77\n3.2.3  五状态模型\t78\n3.2.4  被挂起的进程\t81\n3.3  进程描述\t84\n3.3.1  操作系统的控制结构\t85\n3.3.2  进程控制结构\t86\n3.4  进程控制\t90\n3.4.1  执行模式\t90\n3.4.2  进程创建\t91\n3.4.3  进程切换\t92\n3.5  操作系统的执行\t93\n3.5.1  无进程的内核\t94\n3.5.2  在用户进程中执行\t94\n3.5.3  基于进程的操作系统\t95\n3.6  安全问题\t95\n3.6.1  系统访问威胁\t96\n3.6.2  对抗措施\t96\n3.7  UNIX SVR4进程管理\t98\n3.7.1  进程状态\t98\n3.7.2  进程描述\t99\n3.7.3  进程控制\t101\n3.8  小结\t102\n3.9  推荐读物\t102\n3.10  关键术语、复习题和习题\t102\n编程项目1：开发一个shell程序\t105\n第4章  线程、对称多处理（SMP）\n第4章  和微内核\t107\n4.1  进程和线程\t107\n4.1.1  多线程\t107\n4.1.2  线程功能特性\t109\n4.1.3  例子：Adobe PageMaker\t111\n4.1.4  用户级和内核级线程\t112\n4.1.5  其他方案\t115\n4.2  对称多处理\t116\n4.2.1  SMP体系结构\t116\n4.2.2  SMP系统的组织结构\t117\n4.2.3  多处理器操作系统的\n4.2.3  设计思考\t118\n4.3  微内核\t119\n4.3.1  微内核体系结构\t119\n4.3.2  微内核组织结构的优点\t120\n4.3.3  微内核性能\t121\n4.3.4  微内核设计\t121\n4.4  Windows线程和SMP管理\t122\n4.4.1  进程对象和线程对象\t123\n4.4.2  多线程\t125\n4.4.3  线程状态\t125\n4.4.4  对操作系统子系统的支持\t126\n4.4.5  对称多处理的支持\t126\n4.5  Solaris的线程和SMP管理\t127\n4.5.1  多线程体系结构\t127\n4.5.2  动机\t127\n4.5.3  进程结构\t128\n4.5.4  线程的执行\t129\n4.5.5  把中断当做线程\t129\n4.6  Linux的进程和线程管理\t130\n4.6.1  Linux任务\t130\n4.6.2  Linux线程\t131\n4.7  小结\t132\n4.8  推荐读物\t133\n4.9  关键术语、复习题和习题\t133\n第5章  并发性：互斥和同步\t138\n5.1  并发的原理\t139\n5.1.1  一个简单的例子\t139\n5.1.2  竞争条件\t141\n5.1.3  操作系统关注的问题\t141\n5.1.4  进程的交互\t141\n5.1.5  互斥的要求\t144\n5.2  互斥：硬件的支持\t144\n5.2.1  中断禁用\t144\n5.2.2  专用机器指令\t145\n5.3  信号量\t147\n5.3.1  互斥\t150\n5.3.2  生产者\/消费者问题\t151\n5.3.3  信号量的实现\t154\n5.4  管程\t155\n5.4.1  使用信号的管程\t155\n5.4.2  使用通知和广播的管程\t158\n5.5  消息传递\t159\n5.5.1  同步\t160\n5.5.2  寻址\t161\n5.5.3  消息格式\t162\n5.5.4  排队原则\t162\n5.5.5  互斥\t162\n5.6  读者-写者问题\t163\n5.6.1  读者优先\t164\n5.6.2  写者优先\t164\n5.7  小结\t166\n5.8  推荐读物\t167\n5.9  关键术语、复习题和习题\t167\n第6章  并发：死锁和饥饿\t178\n6.1  死锁的原理\t178\n6.1.1  可重用资源\t180\n6.1.2  可消耗资源\t181\n6.1.3  资源分配图\t182\n6.1.4  死锁的条件\t183\n6.2  死锁预防\t184\n6.2.1  互斥\t184\n6.2.2  占有且等待\t184\n6.2.3  不可抢占\t184\n6.2.4  循环等待\t184\n6.3  死锁避免\t185\n6.3.1  进程启动拒绝\t185\n6.3.2  资源分配拒绝\t186\n6.4  死锁检测\t189\n6.4.1  死锁检测算法\t189\n6.4.2  恢复\t190\n6.5  一种综合的死锁策略\t190\n6.6  哲学家就餐问题\t191\n6.6.1  使用信号量解决方案\t191\n6.6.2  使用管程解决方案\t192\n6.7  UNIX的并发机制\t192\n6.7.1  管道\t192\n6.7.2  消息\t193\n6.7.3  共享内存\t193\n6.7.4  信号量\t194\n6.7.5  信号\t194\n6.8  Linux内核并发机制\t195\n6.8.1  原子操作\t195\n6.8.2  自旋锁\t196\n6.8.3  信号量\t197\n6.8.4  屏障\t199\n6.9  Solaris线程同步原语\t199\n6.9.1  互斥锁\t200\n6.9.2  信号量\t200\n6.9.3  多读者\/单写者锁\t201\n6.9.4  条件变量\t201\n6.10  Windows并发机制\t201\n6.10.1  等待函数\t201\n6.10.2  分派器对象\t202\n6.10.3  临界区\t203\n6.10.4  轻量级读写锁和条件变量\t203\n6.11  小结\t204\n6.12  推荐读物\t204\n6.13  关键术语、复习题和习题\t205\n第三部分  内存\n第7章  内存管理\t210\n7.1  内存管理的需求\t210\n7.1.1  重定位\t210\n7.1.2  保护\t211\n7.1.3  共享\t211\n7.1.4  逻辑组织\t211\n7.1.5  物理组织\t211\n7.2  内存分区\t212\n7.2.1  固定分区\t212\n7.2.2  动态分区\t214\n7.2.3  伙伴系统\t216\n7.2.4  重定位\t218\n7.3  分页\t219\n7.4  分段\t222\n7.5  安全问题\t222\n7.5.1  缓冲区溢出攻击\t222\n7.5.2  预防缓冲区溢出\t225\n7.6  小结\t225\n7.7  推荐读物\t225\n7.8  关键术语、复习题和习题\t225\n附录7A  加载和链接\t228\n第8章  虚拟内存\t232\n8.1  硬件和控制结构\t232\n8.1.1  局部性和虚拟内存\t233\n8.1.2  分页\t235\n8.1.3  分段\t242\n8.1.4  段页式\t243\n8.1.5  保护和共享\t244\n8.2  操作系统软件\t244\n8.2.1  读取策略\t245\n8.2.2  放置策略\t246\n8.2.3  置换策略\t246\n8.2.4  驻留集管理\t251\n8.2.5  清除策略\t255\n8.2.6  加载控制\t255\n8.3  UNIX和Solaris内存管理\t257\n8.3.1  分页系统\t257\n8.3.2  内核内存分配器\t259\n8.4  Linux内存管理\t260\n8.4.1  Linux虚拟内存\t260\n8.4.2  内核内存分配\t261\n8.5  Windows内存管理\t262\n8.5.1  Windows虚拟地址映射\t263\n8.5.2  Windows分页\t263\n8.6  小结\t264\n8.7  推荐读物和网站\t264\n8.8  关键术语、复习题和习题\t265\n附录8A  散列表\t268\n第四部分  调度\n第9章  单处理器调度\t272\n9.1  处理器调度的类型\t272\n9.1.1  长程调度\t273\n9.1.2  中程调度\t274\n9.1.3  短程调度\t274\n9.2  调度算法\t274\n9.2.1  短程调度准则\t274\n9.2.2  优先级的使用\t275\n9.2.3  选择调度策略\t276\n9.2.4  性能比较\t284\n9.2.5  公平共享调度\t287\n9.3  传统的UNIX调度\t289\n9.4  小结\t290\n9.5  推荐读物\t291\n9.6  关键术语、复习题和习题\t291\n附录9A  响应时间\t294\n附录9B  排队系统\t296\n编程项目2：主机调度shell程序\t299\n第10章  多处理器和实时调度\t304\n10.1  多处理器调度\t304\n10.1.1  粒度\t304\n10.1.2  设计问题\t307\n10.1.3  进程调度\t308\n10.1.4  线程调度\t309\n10.2  实时调度\t312\n10.2.1  背景\t312\n10.2.2  实时操作系统的特点\t313\n10.2.3  实时调度\t315\n10.2.4  限期调度\t316\n10.2.5  速率单调调度\t319\n10.2.6  优先级反转\t321\n10.3  Linux调度\t322\n10.3.1  实时调度\t322\n10.3.2  非实时调度\t323\n10.4  UNIX SVR4调度\t325\n10.5  Windows调度\t326\n10.5.1  进程和线程优先级\t326\n10.5.2  多处理器调度\t328\n10.6  小结\t328\n10.7  推荐读物\t328\n10.8  关键术语、复习题和习题\t329\n第五部分  I\/O和文件\n第11章  I\/O管理和磁盘调度\t334\n11.1  I\/O设备\t334\n11.2  I\/O功能的组织\t335\n11.2.1  I\/O功能的发展\t335\n11.2.2  直接存储器访问\t336\n11.3  操作系统设计问题\t337\n11.3.1  设计目标\t337\n11.3.2  I\/O功能的逻辑结构\t338\n11.4  I\/O缓冲\t339\n11.4.1  单缓冲\t340\n11.4.2  双缓冲\t341\n11.4.3  循环缓冲\t341\n11.4.4  缓冲的作用\t341\n11.5  磁盘调度\t342\n11.5.1  磁盘性能参数\t342\n11.5.2  磁盘调度策略\t344\n11.6  RAID\t347\n11.6.1  RAID级别0\t349\n11.6.2  RAID级别1\t350\n11.6.3  RAID级别2\t351\n11.6.4  RAID级别3\t351\n11.6.5  RAID级别4\t352\n11.6.6  RAID级别5\t353\n11.6.7  RAID级别6\t353\n11.7  磁盘高速缓存\t353\n11.7.1  设计考虑\t353\n11.7.2  性能考虑\t355\n11.8  UNIX SVR4 I\/O\t355\n11.8.1  缓冲区高速缓存\t356\n11.8.2  字符队列\t356\n11.8.3  无缓冲I\/O\t357\n11.8.4  UNIX设备\t357\n11.9  Linux I\/O\t357\n11.9.1  磁盘调度\t358\n11.9.2  Linux页面缓存\t360\n11.10  Windows I\/O\t360\n11.10.1  基本I\/O机制\t360\n11.10.2  异步I\/O和同步I\/O\t361\n11.10.3  软件RAID\t361\n11.10.4  卷影复制\t361\n11.10.5  卷加密\t362\n11.11  小结\t362\n11.12  推荐读物\t362\n11.13  关键术语、复习题和习题\t363\n附录11A  磁盘存储设备\t365\n第12章  文件管理\t371\n12.1  概述\t371\n12.1.1  文件和文件系统\t371\n12.1.2  文件结构\t371\n12.1.3  文件管理系统\t373\n12.2  文件组织和访问\t375\n12.2.1  堆\t376\n12.2.2  顺序文件\t376\n12.2.3  索引顺序文件\t377\n12.2.4  索引文件\t377\n12.2.5  直接文件或散列文件\t378\n12.3  文件目录\t378\n12.3.1  内容\t378\n12.3.2  结构\t379\n12.3.3  命名\t380\n12.4  文件共享\t381\n12.4.1  访问权限\t381\n12.4.2  同时访问\t381\n12.5  记录组块\t382\n12.6  二级存储管理\t383\n12.6.1 文件分配\t383\n12.6.2  空闲空间的管理\t387\n12.6.3  卷\t388\n12.6.4  可靠性\t388\n12.7  文件系统安全\t389\n12.8  UNIX文件管理\t390\n12.8.1  索引节点\t391\n12.8.2  文件分配\t392\n12.8.3  目录\t393\n12.8.4  卷结构\t393\n12.8.5  传统的UNIX文件访问\n6.10.4  控制\t393\n12.8.6  UNIX中的访问控制列表\t394\n12.9  Linux虚拟文件系统\t395\n12.9.1  超级块对象\t397\n12.9.2  索引节点对象\t397\n12.9.3  目录项对象\t398\n12.9.4  文件对象\t398\n12.10  Windows文件系统\t398\n12.10.1  NTFS的重要特征\t398\n12.10.2  NTFS卷和文件结构\t399\n12.10.3  可恢复性\t401\n12.11  小结\t402\n12.12  推荐读物\t402\n12.13  关键术语、复习题和习题\t403\n第六部分  嵌入式系统\n第13章  嵌入式操作系统\t406\n13.1  嵌入式系统\t406\n13.2  嵌入式操作系统的特点\t407\n13.2.1  移植现有的商业操作系统\t408\n13.2.2  为特定目的构建的嵌入式\n6.10.4  操作系统\t408\n13.3  eCos\t409\n13.3.1  可配置性\t409\n13.3.2  eCos组件\t411\n13.3.3  eCos调度程序\t414\n13.3.4  eCos线程同步\t415\n13.4  TinyOS\t419\n13.4.1  无线传感器网络\t420\n13.4.2  TinyOS的目标\t420\n13.4.3  TinyOS的组件\t421\n13.4.4  TinyOS的调度程序\t423\n13.4.5  配置例子\t423\n13.4.6  TinyOS的资源接口\t425\n13.5  推荐读物和网站\t426\n13.6  关键术语、复习题和习题\t426\n第七部分  安全\n第14章  计算机安全威胁\t430\n14.1  计算机安全的概念\t430\n14.2  威胁、攻击和资产\t431\n14.2.1  威胁和攻击\t431\n14.2.2  威胁和资产\t432\n14.3  入侵者\t434\n14.3.1  入侵者行为模式\t435\n14.3.2  入侵技术\t437\n14.4  恶意软件概述\t437\n14.4.1  后门\t437\n14.4.2  逻辑炸弹\t438\n14.4.3  特洛伊木马\t438\n14.4.4  移动代码\t438\n14.4.5  多威胁恶意软件\t439\n14.5  病毒、蠕虫与僵尸\t440\n14.5.1  病毒\t440\n14.5.2  蠕虫\t443\n14.5.3  僵尸\t445\n14.6  rootkits\t447\n14.6.1  rootkit安装\t447\n14.6.2  系统级调用攻击\t447\n14.7  推荐读物和网站\t448\n14.8  关键术语、复习题和习题\t448\n第15章  计算机安全技术\t451\n15.1  身份验证\t451\n15.1.1  身份验证方法\t451\n15.1.2  基于密码的身份验证\t451\n15.1.3  基于令牌的身份验证\t453\n15.1.4  生物特征识别认证\t454\n15.2  访问控制\t455\n15.2.1  自主访问控制\t456\n15.2.2  基于角色的访问控制\t458\n15.3  入侵检测\t460\n15.3.1  基本原则\t460\n15.3.2  基于主机的入侵检测技术\t461\n15.3.3  审计记录\t462\n15.4  恶意软件防御\t463\n15.4.1  反病毒方法\t463\n15.4.2  蠕虫对策\t465\n15.4.3  自动代理程序的对策\t466\n15.4.4  rootkit对策\t466\n15.5  处理缓冲区溢出攻击\t467\n15.5.1  编译时防御\t467\n15.5.2  运行时防御\t469\n15.6  Windows Vista安全性\t470\n15.6.1  访问控制方案\t470\n15.6.2  访问令牌\t471\n15.6.3  安全描述符\t471\n15.7  推荐读物和网站\t474\n15.8  关键术语、复习题和习题\t475\n第八部分  分布式系统\n第16章  分布式处理、客户\/服务器和\n第16章  集群\t481\n16.1  客户\/服务器计算模型\t481\n16.1.1  什么是客户\/服务器\n16.1.1  计算模型\t481\n16.1.2  客户\/服务器模型的应用\t482\n16.1.3  中间件\t486\n16.2  分布式消息传递\t487\n16.2.1  可靠性与不可靠性\t488\n16.2.2  阻塞与无阻塞\t488\n16.3  远程过程调用\t489\n16.3.1  参数传递\t490\n16.3.2  参数表示\t490\n16.3.3  客户\/服务器绑定\t490\n16.3.4  同步和异步\t490\n16.3.5  面向对象机制\t491\n16.4  集群\t491\n16.4.1  集群的配置\t491\n16.4.2  操作系统的设计问题\t493\n16.4.3  集群计算机的体系结构\t494\n16.4.4  集群与SMP的比较\t495\n16.5  Windows集群服务器\t495\n16.6  Sun集群\t496\n16.6.1  对象和通信支持\t497\n16.6.2  进程管理\t497\n16.6.3  网络连接\t497\n16.6.4  全局文件系统\t498\n16.7  Beowulf和Linux集群\t498\n16.7.1  Beowulf特征\t498\n16.7.2  Beowulf软件\t499\n16.8  小结\t500\n16.9  推荐读物和网站\t500\n16.10  关键术语、复习题和习题\t501\n附录A  并发主题\t503\n附录B  面向对象设计\t516\n附录C  编程和操作系统项目\t523\n术语表\t528\n参考文献\t536",
      "pages": "572",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s4450637.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s4450637.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s4450637.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/5064311\/",
      "id": "5064311",
      "publisher": "机械工业出版社",
      "isbn10": "7111304268",
      "isbn13": "9787111304265",
      "title": "操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/5064311",
      "alt_title": "Operating Systems: Internals and Design Principles, Sixth Edition",
      "author_intro": "William Stallings 拥有美国麻省理工学院计算机科学博士学位，现任教于澳大利亚新南威尔士大学国防学院（堪培拉）信息技术与电子工程系。他是世界知名计算机学者和畅销教材作者，已经撰写了17部著作，出版了40多本书籍，内容涉及计算机安全、计算机网络和计算机体系结构等方面，堪称计算机界的全才。他曾九次荣获美国“教材和学术专著作者协会”颁发的“年度最佳计算机科学教材”奖。",
      "summary": "本书不仅全面地讲述了操作系统的基本概念、原理和方法，还清楚地展现了当代操作系统的本质和特点。作者针对近几年操作系统领域的最新变化，对操作系统的设计原理进行深入的阐述，同时将其对操作系统整个领域全面而深入的理解呈现给读者。\n本书特色\n·选择Windows Vista、UNIX和Linux三个操作系统作为示例，以帮助读者熟悉当代操作系统的设计原理和实现问题。\n·新增嵌入式操作系统一章，讨论了嵌入式操作系统的基本特点，并给出了两个实例系统：TinyOS和eCos。\n·在第5版的基础上扩展了计算机安全的相关内容，包括计算机安全威胁和计算机安全技术。\n·扩展和更新了并发的相关内容，并增加了有关游戏软件中多处理器调度设计问题的实例。\n·补充动画演示、模拟项目和编程项目，便于培养学生的动手实践能力。\n·改进了插图，增加新的大量 “现场测试”（field-tested）型家庭作业。\n·调整和扩充了章末的练习题，有助于读者深入理解操作系统的精髓。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 253,
        "average": "9.1",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "（美）罗斯（Russinovich,M.E.）",
        "（美）所罗门（Solomon,D.A.）"
      ],
      "pubdate": "2007-4",
      "tags": [
        {
          "count": 275,
          "name": "Windows",
          "title": "Windows"
        },
        {
          "count": 236,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 86,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 71,
          "name": "深入解析Windows操作系统",
          "title": "深入解析Windows操作系统"
        },
        {
          "count": 48,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 40,
          "name": "技术内幕",
          "title": "技术内幕"
        },
        {
          "count": 38,
          "name": "kernel",
          "title": "kernel"
        },
        {
          "count": 34,
          "name": "Win32",
          "title": "Win32"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s4047771.jpg",
      "binding": "平装",
      "translator": [
        "潘爱民"
      ],
      "catalog": "",
      "pages": "941",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s4047771.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s4047771.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s4047771.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/2031396\/",
      "id": "2031396",
      "publisher": "电子工业出版社",
      "isbn10": "7121039699",
      "isbn13": "9787121039690",
      "title": "深入解析Windows操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/2031396",
      "alt_title": "",
      "author_intro": "",
      "summary": "本书是著名的操作系统内核专家Mark Russinovich和David Solomon撰写的Windows操作系统原理的最新版著作，全面和深入地阐述了Windows操作系统的整体结构以及内部工作细节。本书针对Windows Server 2003、Windows XP和Windows 2000做了全面更新，通过许多练习实验让你直接感受到Windows的内部行为。另外，本书还介绍了一些高级诊断技术，以便使你的系统运行得更加平稳和高效。无论你是开发人员还是系统管理员，你都可以在本书中找到一些关键的、有关体系结构方面的知识，通过这些知识你可以更好地做系统设计、调试，以及性能优化……",
      "price": "99.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 168,
        "average": "8.9",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[美]西尔伯查茨(Silberschatz，A.)"
      ],
      "pubdate": "2007-3",
      "tags": [
        {
          "count": 153,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 69,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 56,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 45,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 44,
          "name": "操作系统概念",
          "title": "操作系统概念"
        },
        {
          "count": 30,
          "name": "教材",
          "title": "教材"
        },
        {
          "count": 25,
          "name": "英文原版",
          "title": "英文原版"
        },
        {
          "count": 22,
          "name": "恐龙书",
          "title": "恐龙书"
        }
      ],
      "origin_title": "Operating System Concepts, Seventh Edition",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26014820.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "PART ONE OVERVIEW\nChapter I Introduction\n1.1 What Operating Systems Do\n1.2 Computer-System Organization\n1.3 Comvuter-Svstem Architecture\n1.4 Operating-System Structure\n1.5 Operating-System Operations\n1.6 Process Management\n1.7 Memory Management\n1.8 Storage Management\n1.9 Protection and Security\n1.10 Distributed Systems\n1.11 Special-Purpose Systems\n1.12 Computing Environments\n1.13 Summary\nExercises\nBibliographical Notes\nChapter 2 Operating-System Structures\n2.1 Operating-System Services\n2.2 User Operating-System Interface\n2.3 System Calls\n2.4 Types of System Calls\n2.5 System Programs\n2.6 Operating-System Design and\nImplementation\n2.7 Operating-System Structure\n2.8 Virtual Machines\n2.9 Operating-System Generation\n2.10 System Boot\n2.11 Summary\nExercises\nBibliographical Notes\nPART TWO PROCESS MANAGEMENT\nChapter 3 Processes\n3.1 Process Concept\n3.2 Process Scheduling\n3.3 Operations on Processes\n3.4 Interprocess Communication\n3.5 Examples of IPC Systems\n3.6 Communication in Client-\nServer Svstems\n3.7 Summary\nExercises\nBibliographical Notes\nChapter 4 Threads\n4.1 Overview\n4.2 Multithreading Models\n4.3 Thread Libraries\n4.4 Threading Issues\n4.5 Operating-System Examples\n4.6 Summary\nExercises\nBibliographical Notes\nChapter 5 CPU Scheduling\n5.1 Basic Concepts\n5.2 Scheduling Criteria\n5.3 Scheduling Algorithms\n5.4 Multiple-Processor Scheduling\n5.5 Thread Scheduling\n5.6 Operating System Examples\n5.7 Algorithm Evaluation\n5.8 Summary\nExercises\nBibliographical Notes\nChapter 6 Process Synchronization\n6.1 Background\n6.2 The Critical-Section Problem\n6.3 Peterson's Solution\n6.4 Synchronization Hardware\n6.5 Semaphores\n6.6 Classic Problems of\nSynchronization\n6.7 Monitors\n6.8 Synchronization Examples\n6.9 Atomic Transactions\n6.10 Summary\nExercises\nBibliographical Notes\nChapter 7 Deadlocks\n7.1 System Model\n7.2 Deadlock Characterization\n7.3 Methods for Handling Deadlocks\n7.4 Deadlock Prevention\n7.5 Deadlock Avoidance\n7.6 Deadlock Detection\n7.7 Recovery From Deadlock\n7.8 Summary\nExercises\nBibliographical Notes\nPART THREE MEMORY MANAGEMENT\nChapter 8 Main Memory\nChapter 9 Virtual Memory\nPART FOUR STORAGE MANAGEMENT\nChapter 10 File-System Interface\nChapter 11 File-System Implementation\nChapter 12 Mass-Storage Structure\nChapter 13 I\/O Systems\nPART FIVE PROTECTION AND SECURITY\nChapter 14 Protection\nChapter 15 Security\nPART SIX DISTRIBUTED SYSTEMS\nChapter 16 Distributed System Structures\nChapter 17 Distributed File Systems\nChapter 18. Distributed Coordination\nPART SEVEN SPECIAL-PURPOSE SYSTEMS\nChapter 19 Real-Time Systems\nChapter 20 Multimedia Systems\nPART EIGHT CASE STUDIES\nChapter 21 The Linux System\nChapter 22 Windows XP\nChapter 23 Influential Operating Systems\nAppendix A UNIX BSD (contents online)\nAppendix B The Mach System (contents online)\nAppendix C Windows 2000 (contents online)",
      "pages": "921",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s26014820.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s26014820.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s26014820.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/2109679\/",
      "id": "2109679",
      "publisher": "高等教育出版社",
      "isbn10": "7040209284",
      "isbn13": "9787040209280",
      "title": "操作系统概念",
      "url": "https:\/\/api.douban.com\/v2\/book\/2109679",
      "alt_title": "Operating System Concepts, Seventh Edition",
      "author_intro": "",
      "summary": "操作系统概念（第7版 影印版），ISBN：9787040209280，作者：（美）西尔伯查茨 高尔文 加根",
      "series": {
        "id": "23766",
        "title": "国外优秀信息科学与技术系列教学用书"
      },
      "price": "72.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 311,
        "average": "7.9",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "于渊"
      ],
      "pubdate": "2005-8",
      "tags": [
        {
          "count": 415,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 157,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 119,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 95,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 68,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 64,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 40,
          "name": "程序开发",
          "title": "程序开发"
        },
        {
          "count": 36,
          "name": "Programming",
          "title": "Programming"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1435462.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "",
      "pages": "374",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1435462.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1435462.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1435462.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1422377\/",
      "id": "1422377",
      "publisher": "电子工业出版社",
      "isbn10": "7121015773",
      "isbn13": "9787121015779",
      "title": "自己动手写操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1422377",
      "alt_title": "",
      "author_intro": "",
      "summary": "本书在详细分析操作系统原理的基础上，用丰富的实例代码，一步一步地指导读者用C语言和汇编语言编写出一个具备操作系统基本功能的操作系统框架。本书不同于其他的理论型书籍，而是提供给读者一个动手实践的路线图。书中讲解了大量在开发操作系统中需注意的细节问题，这些细节不仅能使读者更深刻地认识操作系统的核心原理，而且使整个开发过程少走弯路。全书共分7章。附CD-ROM光盘一张。",
      "price": "48.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 207,
        "average": "9.2",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "Andrew S. Tanenbaum",
        "Albert S. Woodhull"
      ],
      "pubdate": "2007-3",
      "tags": [
        {
          "count": 325,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 116,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 70,
          "name": "os",
          "title": "os"
        },
        {
          "count": 68,
          "name": "minix",
          "title": "minix"
        },
        {
          "count": 66,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 58,
          "name": "操作系统设计与实现",
          "title": "操作系统设计与实现"
        },
        {
          "count": 30,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 29,
          "name": "经典",
          "title": "经典"
        }
      ],
      "origin_title": "Operating Systems:Design and Implementation",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s5811568.jpg",
      "binding": "平装",
      "translator": [
        "陈渝",
        "谌卫军"
      ],
      "catalog": "",
      "pages": "453",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s5811568.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s5811568.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s5811568.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/2044818\/",
      "id": "2044818",
      "publisher": "电子工业出版社",
      "isbn10": "712103381X",
      "isbn13": "9787121033810",
      "title": "操作系统设计与实现（上册）",
      "url": "https:\/\/api.douban.com\/v2\/book\/2044818",
      "alt_title": "Operating Systems:Design and Implementation",
      "author_intro": "Andrew S.Tanenbaum分别在麻省理工学院加州大学伯克利分校获得学士与博士学位。现任荷兰阿姆斯特丹Vrije大学计算机教授并领导着一个计算机系统研究小组。到2005年1月卸任为止，他担任计算与成像高级学院院长一职已有12年。\nTanenbaum过去的研究领域包括编译器、操作系统、网络和局域分布式系统，而现在的研究方向则主要为计算机安全，尤其是操作系统、网络以及分布式系统的安全。在所有这些研究领域，Tanenbaum发表了超过100篇论文，并出版了5本书籍。\nTanenbaum教授还编写了大量软件。他是Amsterdam Compiler Kit（一种广泛使用的、用于编写可移植编译器以及MINIX的工具集）的主要开发者，而该系统则是Linux诞生的灵感与基础。与他的博士生及程序员一起，他帮助设计了Amoeba分布式操作系统（一个基于微内核的、高性能局域分布式操作系统）。此后，他是Globe（一个可处理10亿用户的广域分布式操作系统）的设计者之一。所有这些软件现在均可在互联网上免费获得。\n他的博士生在毕业后均取得了很大的成绩，他为此感到非常骄傲。\nTanenbaum教授是ACM会士、IEEE会士以及荷兰皇家科学艺术院院士。他还是1994年度ACM Karl V.Karlstrom杰出教育家奖的获得者，1997年度ACM\/SIGCSE计算机科学教育杰出贡献奖的获得者，以及2002年度优秀教材奖的获得者。2004年，他被推选为荷兰皇家学会的五位新学会教授之一。",
      "summary": "本书是关于操作系统的权威教材。大多数关于操作系统的图书均重理论而轻实践，而本书则在这两者之间进行了较好的折中。本册详细探讨了操作系统的基本原理，包括进程、进程间通信、信号量、管程、消息传递、调度算法、输入、输出、死锁、设备驱动程序、存储管理、调页算法、文件系统设计、安全和保护机制等；此外，还详细讨论了一个特殊的操作系统MINIX 3（一个与UNIX兼容的操作系统），并提供了该系统的源代码（见本书下册），以便于读者仔细研究。这种安排不仅可让读者了解操作系统的基本原理，而且可让读者了解到这些基本原理是如何应用到真实的操作系统中去的。\n本书适用于高校计算机专业的学生，也可供程序设计人员、工程技术人员、系统架构师等相关人员参考。",
      "series": {
        "id": "35164",
        "title": "国外计算机科学教材系列"
      },
      "price": "49.80元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 51,
        "average": "8.4",
        "min": 0
      },
      "subtitle": "系统构建和原理解析",
      "author": [
        "王柏生"
      ],
      "pubdate": "2013-10-15",
      "tags": [
        {
          "count": 102,
          "name": "linux",
          "title": "linux"
        },
        {
          "count": 88,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 82,
          "name": "Linux",
          "title": "Linux"
        },
        {
          "count": 36,
          "name": "内核",
          "title": "内核"
        },
        {
          "count": 31,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 24,
          "name": "kernel",
          "title": "kernel"
        },
        {
          "count": 23,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 23,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "深度探索Linux操作系统",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s27318529.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "《深度探索linux操作系统：系统构建和原理解析》\n前　　言\n第1章　准备基本环境\t1\n1.1　安装virtualbox\t1\n1.2　创建虚拟计算机\t2\n1.3　安装linux系统\t2\n1.4　使用root用户\t5\n1.5　启用自动登录\t5\n1.6　挂载实验分区\t6\n1.7　安装ssh服务器\t6\n1.8　更改网络模式\t7\n1.9　安装增强模式\t8\n1.10　使用xephyr\t8\n第2章　工具链\t10\n2.1　编译过程\t10\n2.1.1　预编译\t12\n2.1.2　编译\t14\n2.1.3　汇编\t17\n2.1.4　链接\t31\n2.2　构建工具链\t39\n.2.2.1　gnu工具链组成\t40\n2.2.2　构建工具链的过程\t40\n2.2.3　准备工作\t43\n2.2.4　构建二进制工具\t45\n2.2.5　编译freestanding的交叉编译器\t46\n2.2.6　安装内核头文件\t49\n2.2.7　编译目标系统的c库\t50\n2.2.8　构建完整的交叉编译器\t52\n2.2.9　定义工具链相关的环境变量\t54\n2.2.10　封装“交叉”pkg-config\t54\n2.2.11　关于使用libtool链接库的讨论\t56\n2.2.12　启动代码\t57\n第3章　构建内核\t62\n3.1　内核映像的组成\t62\n3.1.1　一级推进系统——setup.bin\t63\n3.1.2　二级推进系统——内核非压缩部分\t65\n3.1.3　有效载荷——vmlinux\t65\n3.1.4　映像的格式\t66\n3.2　内核映像的构建过程\t68\n3.2.1　kbuild简介\t68\n3.2.2　构建过程概述\t71\n3.2.3　vmlinux的构建过程\t71\n3.2.4　vmlinux.bin的构建过程\t75\n3.2.5　setup.bin的构建过程\t80\n3.2.6　bzimage的组合过程\t81\n3.2.7　内核映像构建过程总结\t82\n3.3　配置内核\t86\n3.3.1　交叉编译内核设置\t86\n3.3.2　基本内核配置\t87\n3.3.3　配置处理器\t88\n3.3.4　配置内核支持模块\t90\n3.3.5　配置硬盘控制器驱动\t91\n3.3.6　配置文件系统\t96\n3.3.7　配置内核支持elf文件格式\t97\n3.4　构建基本根文件系统\t99\n3.4.1　根文件系统的基本目录结构\t99\n3.4.2　安装c库\t100\n3.4.3　安装shell\t101\n3.4.4　安装根文件系统到目标系统\t102\n第4章　构建initramfs\t104\n4.1　为什么需要initramfs\t104\n4.2　initramfs原理探讨\t105\n4.2.1　挂载rootfs\t106\n4.2.2　解压initramfs到rootfs\t110\n4.2.3　挂载并切换到真正的根目录\t116\n4.3　配置内核支持initramfs\t117\n4.4　构建基本的initramfs\t118\n4.5　将硬盘驱动编译为模块\t121\n4.5.1　配置devtmpfs\t121\n4.5.2　将硬盘控制器驱动配置为模块\t126\n4.6　自动加载硬盘控制器驱动\t130\n4.6.1　内核向用户空间发送事件\t131\n4.6.2　udev加载驱动和建立设备节点\t136\n4.6.3　处理冷插拔设备\t139\n4.6.4　编译安装udev\t141\n4.6.5　配置内核支持netlink\t142\n4.6.6　配置内核支持inotify\t143\n4.6.7　安装modules.alias.bin文件\t144\n4.6.8　启动udevd和模拟热插拔\t146\n4.7　挂载并切换到根文件系统\t147\n4.7.1　挂载根文件系统\t147\n4.7.2　切换到根文件系统\t149\n第5章　从内核空间到用户空间\t154\n5.1　linux操作系统加载\t154\n5.1.1　grub映像构成\t155\n5.1.2　安装grub\t160\n5.1.3　grub启动过程\t165\n5.1.4　加载内核和initramfs\t170\n5.2　解压内核\t181\n5.2.1　移动内核映像\t182\n5.2.2　解压\t186\n5.2.3　重定位\t187\n5.3　内核初始化\t190\n5.3.1　初始化虚拟内存\t190\n5.3.2　初始化进程0\t201\n5.3.3　创建进程1\t206\n5.4　进程加载\t209\n5.4.1　加载可执行程序\t211\n5.4.2　进程的投入运行\t223\n5.4.3　按需载入指令和数据\t234\n5.4.4　加载动态链接器\t243\n5.4.5　加载动态库\t246\n5.4.6　重定位动态库\t250\n5.4.7　重定位可执行程序\t268\n5.4.8　重定位动态链接器\t271\n5.4.9　段relro\t274\n第6章　构建根文件系统\t278\n6.1　初始根文件系统\t278\n6.2　以读写模式重新挂载文件系统\t280\n6.3　配置内核支持网络\t282\n6.3.1　配置内核支持tcp\/ip协议\t282\n6.3.2　配置内核支持网卡\t283\n6.4　启动udev\t285\n6.5　安装网络配置工具并配置网络\t285\n6.6　安装并配置ssh服务\t287\n6.7　安装procps\t291\n6.8　安装x窗口系统\t291\n6.8.1　安装m4宏定义\t292\n6.8.2　安装x协议和扩展\t292\n6.8.3　安装x相关库和工具\t294\n6.8.4　安装x服务器\t296\n6.8.5　安装gpu的2d驱动\t297\n6.8.6　安装x的输入设备驱动\t297\n6.8.7　运行x服务器\t300\n6.8.8　一个简单的x程序\t302\n6.8.9　配置内核支持drm\t303\n6.9　安装图形库\t307\n6.9.1　安装glib和libffi\t307\n6.9.2　安装atk\t307\n6.9.3　安装libpng\t308\n6.9.4　安装gdkpixbuf\t308\n6.9.5　安装fontconfig\t308\n6.9.6　安装cairo\t311\n6.9.7　安装pango\t311\n6.9.8　安装libxi\t311\n6.9.9　安装gtk\t312\n6.9.10　安装gtk图形库的善后工作\t312\n6.9.11　一个简单的gtk程序\t313\n6.10　安装字体\t315\n第7章　构建桌面环境\t317\n7.1　窗口管理器\t317\n7.1.1　基本原理\t318\n7.1.2　创建编译脚本\t325\n7.1.3　主要数据结构\t328\n7.1.4　初始化\t331\n7.1.5　为窗口“落户”\t334\n7.1.6　构建窗口装饰\t337\n7.1.7　绘制装饰窗口\t341\n7.1.8　配置窗口\t343\n7.1.9　移动窗口\t345\n7.1.10　改变窗口大小\t348\n7.1.11　切换窗口\t348\n7.1.12　最大化\/最小化\/关闭窗口\t351\n7.1.13　管理已存在的窗口\t354\n7.2　任务条和桌面\t356\n7.2.1　标识任务条的身份\t357\n7.2.2　更新任务条上的任务项\t358\n7.2.3　激活任务\t359\n7.2.4　高亮显示当前活动任务\t360\n7.2.5　显示桌面\t361\n7.2.6　桌面\t362\n第8章　linux图形原理探讨\t364\n8.1　渲染和显示\t364\n8.1.1　渲染\t365\n8.1.2　显示\t365\n8.2　显存\t366\n8.2.1　动态显存技术\t367\n8.2.2　buffer object\t370\n8.3　2d渲染\t375\n8.3.1　创建前缓冲\t377\n8.3.2　gpu渲染\t381\n8.3.3　cpu渲染\t386\n8.4　3d渲染\t388\n8.4.1　创建帧缓冲\t390\n8.4.2　渲染pipleline\t399\n8.4.3　交换前缓冲和后缓冲\t414\n8.5　wayland\t421",
      "ebook_url": "https:\/\/read.douban.com\/ebook\/3967543\/",
      "pages": "421",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s27318529.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s27318529.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s27318529.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/25743846\/",
      "id": "25743846",
      "publisher": "机械工业出版社",
      "isbn10": "7111439015",
      "isbn13": "9787111439011",
      "title": "深度探索Linux操作系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/25743846",
      "alt_title": "深度探索Linux操作系统",
      "author_intro": "",
      "summary": "《深度探索linux操作系统：系统构建和原理解析》是探索linux操作系统原理的里程碑之作，在众多的同类书中独树一帜。它颠覆和摒弃了传统的从阅读linux内核源代码着手学习linux操作系统原理的方式，而是基于实践，以从零开始构建一个完整的linux操作系统的过程为依托，指引读者在实践中去探索操作系统的本质。这种方式的妙处在于，让读者先从宏观上全面认清一个完整的操作系统中都包含哪些组件，各个组件的作用，以及各个组件间的关系，从微观上深入理解系统各个组件的原理，帮助读者达到事半功倍的学习效果，这是作者潜心研究linux操作系统10几年的心得和经验，能避免后来者在学习中再走弯路。此外，本书还对编译链接技术（尤其是动态加载和链接技术）和图形系统进行了原理性的探讨，这部分内容非常珍贵。\n全书一共8章：第1章介绍了如何准备工作环境。在第2章中构建了编译工具链，这是后面构建操作系统各个组件的基础。在这一章中，不仅详细讲解了工具链的构建过程，而且还通过对编译链接过程的探讨，深入讨论了工具链的组成及各个组件的作用，理解工具链的工作原理对理解操作系统至关重要。第3~4章，从零开始构建了一个具备用户字符界面的最小操作系统，详细讲解了构建的过程以及涉及的技术细节。第5章从理论的角度探讨了这一过程，从内核的加载、解压一直讨论到用户进程的加载，包括用户空间的动态链接器为加载程序所作的努力。第6~7章首先构建了操作系统的基础图形系统，然后在此基础上构建了桌面环境。第8章深入探讨了计算机图形的基础原理，包含2d和3d程序的渲染、软件渲染、硬件渲染等内容，同时也从操作系统的角度审视了pipeline。",
      "ebook_price": "30.00",
      "price": "89.00"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 96,
        "average": "8.3",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "（美）西尔伯查茨",
        "（美）高尔文",
        "（美）加根"
      ],
      "pubdate": "2010-1",
      "tags": [
        {
          "count": 153,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 62,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 31,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 26,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 18,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 18,
          "name": "经典",
          "title": "经典"
        },
        {
          "count": 13,
          "name": "中文版",
          "title": "中文版"
        },
        {
          "count": 11,
          "name": "教材",
          "title": "教材"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s22791741.jpg",
      "binding": "",
      "translator": [
        "郑扣根"
      ],
      "catalog": "第一部分 概述\n第1章 导论\n第2章 操作系统结构\n第二部分 进程管理\n第3章 进程\n第4章 线程\n第5章 CPU调度\n第6章 进程同步\n第7章 死锁\n第三部分 内存管理\n第8章 内存管理\n第9章 虚拟内存\n第四部分 存储管理\n第10章 文件系统接口\n第11章 文件系统实现\n第12章 大容量存储器的结构\n第13章 I／O输入系统\n第五部分 保护与安全\n第14章 保护\n第15章 安全\n第六部分 分布式系统\n第16章 分布式系统结构\n第17章 分布式文件系统\n第18章 分布式协调\n第七部分 特殊用途系统\n第19章 实时系统\n第20章 多媒体系统\n第八部分 案例研究\n第21章 Linux系统\n第22章 Windows XP\n第23章 用影响的操作系统\n参考文献\n原版相关内容引用表\n英汉名词对照表",
      "pages": "805",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s22791741.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s22791741.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s22791741.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/4289836\/",
      "id": "4289836",
      "publisher": "高等教育出版社",
      "isbn10": "7040283417",
      "isbn13": "9787040283419",
      "title": "操作系统概念（第七版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/4289836",
      "alt_title": "",
      "author_intro": "Abraham Silberschatz是美国耶鲁大学计算机科学系教授。前任新泽西州Murray Hill的贝尔实验室信息科学研究中，Peter Baer Galvin是技术合作公司的技术主管，曾任美国布朗大学计算机科学系的系统主管。作为顾问和培训教师，他在世界各地讲解和教授网络系统管理、安全和性能等。Greg Gagne是美国盐湖城威斯特敏斯特学院计算机科学与数学系主任。除了讲授操作系统外，他还教授计算机网络＼分布式系统＼面向对象程序设计和数据结构等。",
      "summary": "《操作系统概念(第7版)(翻译版)》内容简介：非常小型的操作系统，如篇首的小恐龙所使用的驱动手持设备的操作系统，是Silberschatz、Galvin和Gagne第七版《操作系统概念》中的一种前沿应用。通过保留最新的，保持有意义的，并改编为课程最需要的内容，这本引导市场潮流的教材继续指导着操作系统课程。第七版不仅提供最新且最有意义的系统，同时还从更深层次揭示了那些在当今操作系统发展过程中仍保持不变的基本概念。通过拥有这种坚实的概念基础，学生们能更容易理解与特定系统相关的细节问题。",
      "price": "74.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 50,
        "average": "9.1",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "郑钢"
      ],
      "pubdate": "2016-3",
      "tags": [
        {
          "count": 149,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 55,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 39,
          "name": "OS",
          "title": "OS"
        },
        {
          "count": 37,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 23,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 22,
          "name": "操作系统真象还原",
          "title": "操作系统真象还原"
        },
        {
          "count": 21,
          "name": "计算机基础",
          "title": "计算机基础"
        },
        {
          "count": 11,
          "name": "科普",
          "title": "科普"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s28513411.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "第0章 一些你可能正感到迷惑的问题\t1\n0.1 操作系统是什么\t1\n0.2 你想研究到什么程度\t2\n0.3 写操作系统，哪些需要我来做\t2\n0.4 软件是如何访问硬件的\t2\n0.5 应用程序是什么，和操作系统是如何\n配合到一起的\t3\n0.6 为什么称为“陷入”内核\t4\n0.7 内存访问为什么要分段\t4\n0.8 代码中为什么分为代码段、数据段？\n这和内存访问机制中的段是一回事吗\t6\n0.9 物理地址、逻辑地址、有效地址、线性\n地址、虚拟地址的区别\t11\n0.10 什么是段重叠\t12\n0.11 什么是平坦模型\t12\n0.12 cs、ds这类sreg段寄存器，位宽是\n多少\t12\n0.13 什么是工程，什么是协议\t13\n0.14 为什么Linux系统下的应用程序不能在\nWindows系统下运行\t14\n0.15 局部变量和函数参数为什么要放在\n栈中\t14\n0.16 为什么说汇编语言比C语言快\t15\n0.17 先有的语言，还是先有的编译器，第1个\n编译器是怎么产生的\t16\n0.18 编译型程序与解释型程序的区别\t19\n0.19 什么是大端字节序、小端字节序\t19\n0.20 BIOS中断、DOS中断、Linux中断的\n区别\t21\n0.21 Section和Segment的区别\t25\n0.22 什么是魔数\t29\n0.23 操作系统是如何识别文件系统的\t30\n0.24 如何控制CPU的下一条指令\t30\n0.25 指令集、体系结构、微架构、编程\n语言\t30\n0.26 库函数是用户进程与内核的桥梁\t33\n0.27 转义字符与ASCII码\t37\n0.28 MBR、EBR、DBR和OBR各是\n什么\t39\n第1章 部署工作环境\t42\n1.1 工欲善其事，必先利其器\t42\n1.2 我们需要哪些编译器\t42\n1.2.1 世界顶级编译器GCC\t42\n1.2.2 汇编语言编译器新贵NASM\t43\n1.3 操作系统的宿主环境\t43\n1.3.1 什么是虚拟机\t44\n1.3.2 盗梦空间般的开发环境，虚拟机\n中再装一个虚拟机\t45\n1.3.3 virtualBox下载，安装\t46\n1.3.4 Linux发行版下载\t46\n1.3.5 Bochs下载安装\t46\n1.4 配置bochs\t48\n1.5 运行bochs\t49\n第2章 编写MBR主引导记录，让我们开始\n掌权\t52\n2.1 计算机的启动过程\t52\n2.2 软件接力第一棒，BIOS\t52\n2.2.1 实模式下的1MB内存布局\t52\n2.2.2 BIOS是如何苏醒的\t54\n2.2.3 为什么是0x7c00\t56\n2.3 让MBR先飞一会儿\t58\n2.3.1 神奇好用的$和$$，令人迷惑的\nsection\t58\n2.3.2 NASM简单用法\t60\n2.3.3 请下一位选手MBR同学做\n准备\t60\n第3章 完善MBR\t65\n3.1 地址、section、vstart浅尝辄止\t65\n3.1.1 什么是地址\t65\n3.1.2 什么是section\t67\n3.1.3 什么是vstart\t68\n3.2 CPU的实模式\t70\n3.2.1 CPU的工作原理\t71\n3.2.2 实模式下的寄存器\t72\n3.2.3 实模式下内存分段由来\t76\n3.2.4 实模式下CPU内存寻址方式\t78\n3.2.5 栈到底是什么玩意儿\t81\n3.2.6 实模式下的ret\t84\n3.2.7 实模式下的call\t85\n3.2.8 实模式下的jmp\t92\n3.2.9 标志寄存器flags\t97\n3.2.10 有条件转移\t99\n3.2.11 实模式小结\t101\n3.3 让我们直接对显示器说点什么吧\t101\n3.3.1 CPU如何与外设通信—IO\n接口\t101\n3.3.2 显卡概述\t105\n3.3.3 显存、显卡、显示器\t106\n3.3.4 改进MBR，直接操作显卡\t110\n3.4 bochs调试方法\t112\n3.4.1 bochs一般用法\t113\n3.4.2 bochs调试实例\t118\n3.5 硬盘介绍\t122\n3.5.1 硬盘发展简史\t122\n3.5.2 硬盘工作原理\t123\n3.5.3 硬盘控制器端口\t126\n3.5.4 常用的硬盘操作方法\t128\n3.6 让MBR使用硬盘\t129\n3.6.1 改造MBR\t130\n3.6.2 实现内核加载器\t134\n第4章 保护模式入门\t136\n4.1 保护模式概述\t136\n4.1.1 为什么要有保护模式\t136\n4.1.2 实模式不是32位CPU，变成了\n16位\t137\n4.2 初见保护模式\t137\n4.2.1 保护模式之寄存器扩展\t137\n4.2.2 保护模式之寻址扩展\t140\n4.2.3 保护模式之运行模式反转\t141\n4.2.4 保护模式之指令扩展\t145\n4.3 全局描述符表\t150\n4.3.1 段描述符\t150\n4.3.2 全局描述符表GDT、局部描述\n符表LDT及选择子\t155\n4.3.3 打开A20地址线\t157\n4.3.4 保护模式的开关，CR0寄存器的\nPE位\t158\n4.3.5 让我们进入保护模式\t158\n4.4 处理器微架构简介\t165\n4.4.1 流水线\t166\n4.4.2 乱序执行\t168\n4.4.3 缓存\t168\n4.4.4 分支预测\t169\n4.5 使用远跳转指令清空流水线，更新段描述\n符缓冲寄存器\t172\n4.6 保护模式之内存段的保护\t173\n4.6.1 向段寄存器加载选择子时的\n保护\t173\n4.6.2 代码段和数据段的保护\t174\n4.6.3 栈段的保护\t175\n第5章 保护模式进阶，向内核迈进\t177\n5.1 获取物理内存容量\t177\n5.1.1 学习Linux获取内存的方法\t177\n5.1.2 利用BIOS中断0x15子功能\n0xe820获取内存\t177\n5.1.3 利用BIOS中断0x15子功能\n0xe801获取内存\t179\n5.1.4 利用BIOS中断0x15子功能\n0x88获取内存\t180\n5.1.5 实战内存容量检测\t181\n5.2 启用内存分页机制，畅游虚拟空间\t186\n5.2.1 内存为什么要分页\t186\n5.2.2 一级页表\t188\n5.2.3 二级页表\t192\n5.2.4 规划页表之操作系统与用户\n进程的关系\t197\n5.2.5 启用分页机制\t198\n5.2.6 用虚拟地址访问页表\t204\n5.2.7 快表TLB（Translation Lookaside\nBuffer）简介\t206\n5.3 加载内核\t207\n5.3.1 用C语言写内核\t207\n5.3.2 二进制程序的运行方法\t211\n5.3.3 elf格式的二进制文件\t213\n5.3.4 elf文件实例分析\t218\n5.3.5 将内核载入内存\t222\n5.4 特权级深入浅出\t229\n5.4.1 特权级那点事\t229\n5.4.2 TSS简介\t230\n5.4.3 CPL和DPL入门\t232\n5.4.4 门、调用门与RPL序\t235\n5.4.5 调用门的过程保护\t240\n5.4.6 RPL的前世今生\t243\n5.4.7 IO特权级\t248\n第6章 完善内核\t252\n6.1 函数调用约定简介\t252\n6.2 汇编语言和C语言混合编程\t256\n6.2.1 浅析C库函数与系统调用\t256\n6.2.2 汇编语言和C语言共同协作\t259\n6.3 实现自己的打印函数\t261\n6.3.1 显卡的端口控制\t261\n6.3.2 实现单个字符打印\t265\n6.3.3 实现字符串打印\t275\n6.3.4 实现整数打印\t277\n6.4 内联汇编\t281\n6.4.1 什么是内联汇编\t281\n6.4.2 汇编语言AT&T语法简介\t281\n6.4.3 基本内联汇编\t283\n6.4.4 扩展内联汇编\t284\n6.4.5 扩展内联汇编之机器模式简介\t294\n第7章 中断\t298\n7.1 中断是什么，为什么要有中断\t298\n7.2 操作系统是中断驱动的\t299\n7.3 中断分类\t299\n7.3.1 外部中断\t299\n7.3.2 内部中断\t301\n7.4 中断描述符表\t304\n7.4.1 中断处理过程及保护\t306\n7.4.2 中断发生时的压栈\t308\n7.4.3 中断错误码\t310\n7.5 可编程中断控制器8259A\t311\n7.5.1 8259A介绍\t311\n7.5.2 8259A的编程\t314\n7.6 编写中断处理程序\t319\n7.6.1 从最简单的中断处理程序\n开始\t319\n7.6.2 改进中断处理程序\t335\n7.6.3 调试实战：处理器进入中断时\n压栈出栈完整过程\t339\n7.7 可编程计数器\/定时器8253简介\t346\n7.7.1 时钟—给设备打拍子\t346\n7.7.2 8253入门\t348\n7.7.3 8253控制字\t349\n7.7.4 8253工作方式\t350\n7.7.5 8253初始化步骤\t353\n7.8 提高时钟中断的频率，让中断来得更\n猛烈一些\t354\n第8章 内存管理系统\t357\n8.1 makefile简介\t357\n8.1.1 makefile是什么\t357\n8.1.2 makefile基本语法\t358\n8.1.3 跳到目标处执行\t360\n8.1.4 伪目标\t361\n8.1.5 make：递归式推导目标\t362\n8.1.6 自定义变量与系统变量\t363\n8.1.7 隐含规则\t365\n8.1.8 自动化变量\t366\n8.1.9 模式规则\t367\n8.2 实现assert断言\t367\n8.2.1 实现开、关中断的函数\t367\n8.2.2 实现ASSERT\t370\n8.2.3 通过makefile来编译\t372\n8.3 实现字符串操作函数\t374\n8.4 位图bitmap及其函数的实现\t377\n8.4.1 位图简介\t377\n8.4.2 位图的定义与实现\t378\n8.5 内存管理系统\t381\n8.5.1 内存池规划\t381\n8.5.2 内存管理系统第一步，分配页\n内存\t388\n第9章 线程\t398\n9.1 实现内核线程\t398\n9.1.1 执行流\t398\n9.1.2 线程到底是什么\t399\n9.1.3 进程与线程的关系、区别简述\t402\n9.1.4 进程、线程的状态\t405\n9.1.5 进程的身份证—PCB\t405\n9.1.6 实现线程的两种方式—内核或\n用户进程\t406\n9.2 在内核空间实现线程\t409\n9.2.1 简单的PCB及线程栈的实现\t409\n9.2.2 线程的实现\t413\n9.3 核心数据结构，双向链表\t417\n9.4 多线程调度\t421\n9.4.1 简单优先级调度的基础\t421\n9.4.2 任务调度器和任务切换\t425\n第10章 输入输出系统\t439\n10.1 同步机制——锁\t439\n10.1.1 排查GP异常，理解原子操作\t439\n10.1.2 找出代码中的临界区、互斥、\n竞争条件\t444\n10.1.3 信号量\t445\n10.1.4 线程的阻塞与唤醒\t447\n10.1.5 锁的实现\t449\n10.2 用锁实现终端输出\t452\n10.3 从键盘获取输入\t456\n10.3.1 键盘输入原理简介\t456\n10.3.2 键盘扫描码\t457\n10.3.3 8042简介\t463\n10.3.4 测试键盘中断处理程序\t465\n10.4 编写键盘驱动\t468\n10.4.1 转义字符介绍\t468\n10.4.2 处理扫描码\t469\n10.5 环形输入缓冲区\t476\n10.5.1 生产者与消费者问题简述\t476\n10.5.2 环形缓冲区的实现\t478\n10.5.3 添加键盘输入缓冲区\t481\n10.5.4 生产者与消费者实例测试\t482\n第11章 用户进程\t485\n11.1 为什么要有任务状态段TSS\t485\n11.1.1 多任务的起源，很久很久\n以前…… 485\n11.1.2 LDT简介\t486\n11.1.3 TSS的作用\t488\n11.1.4 CPU原生支持的任务切换\n方式\t492\n11.1.5 现代操作系统采用的任务\n切换方式\t495\n11.2 定义并初始化TSS\t497\n11.3 实现用户进程\t501\n11.3.1 实现用户进程的原理\t501\n11.3.2 用户进程的虚拟地址空间\t501\n11.3.3 为进程创建页表和3特权\n级栈\t502\n11.3.4 进入特权级3\t505\n11.3.5 用户进程创建的流程\t506\n11.3.6 实现用户进程—上\t507\n11.3.7 bss简介\t513\n11.3.8 实现用户进程—下\t515\n11.3.9 让进程跑起来—用户进程的\n调度\t519\n11.3.10 测试用户进程\t520\n第12章 进一步完善内核\t523\n12.1 Linux系统调用浅析\t523\n12.2 系统调用的实现\t527\n12.2.1 系统调用实现框架\t527\n12.2.2 增加0x80号中断描述符\t527\n12.2.3 实现系统调用接口\t528\n12.2.4 增加0x80号中断处理例程\t528\n12.2.5 初始化系统调用和实现\nsys_getpid\t530\n12.2.6 添加系统调用getpid\t531\n12.2.7 在用户进程中的系统调用\t532\n12.2.8 系统调用之栈传递参数\t534\n12.3 让用户进程“说话”\t536\n12.3.1 可变参数的原理\t536\n12.3.2 实现系统调用write\t538\n12.3.3 实现printf\t539\n12.3.4 完善printf\t542\n12.4 完善堆内存管理\t545\n12.4.1 malloc底层原理\t545\n12.4.2 底层初始化\t548\n12.4.3 实现sys_malloc\t550\n12.4.4 内存的释放\t555\n12.4.5 实现sys_free\t558\n12.4.6 实现系统调用malloc和free\t562\n第13章 编写硬盘驱动程序\t566\n13.1 硬盘及分区表\t566\n13.1.1 创建从盘及获取安装的\n磁盘数\t566\n13.1.2 创建磁盘分区表\t567\n13.1.3 磁盘分区表浅析\t571\n13.2 编写硬盘驱动程序\t578\n13.2.1 硬盘初始化\t578\n13.2.2 实现thread_yield和idle线程\t582\n13.2.3 实现简单的休眠函数\t584\n13.2.4 完善硬盘驱动程序\t585\n13.2.5 获取硬盘信息，扫描分区表\t590\n第14章 文件系统\t595\n14.1 文件系统概念简介\t595\n14.1.1 inode、间接块索引表、文件\n控制块FCB简介\t595\n14.1.2 目录项与目录简介\t597\n14.1.3 超级块与文件系统布局\t599\n14.2 创建文件系统\t601\n14.2.1 创建超级块、i结点、目录项\t601\n14.2.2 创建文件系统\t603\n14.2.3 挂载分区\t609\n14.3 文件描述符简介\t612\n14.3.1 文件描述符原理\t612\n14.3.2 文件描述符的实现\t614\n14.4 文件操作相关的基础函数\t615\n14.4.1 inode操作有关的函数\t616\n14.4.2 文件相关的函数\t620\n14.4.3 目录相关的函数\t623\n14.4.4 路径解析相关的函数\t628\n14.4.5 实现文件检索功能\t630\n14.5 创建文件\t633\n14.5.1 实现file_create\t633\n14.5.2 实现sys_open\t636\n14.5.3 在文件系统上创建第1个\n文件\t639\n14.6 文件的打开与关闭\t640\n14.6.1 文件的打开\t640\n14.6.2 文件的关闭\t642\n14.7 实现文件写入\t643\n14.7.1 实现file_write\t643\n14.7.2 改进sys_write及write系统\n调用\t648\n14.7.3 把数据写入文件\t650\n14.8 读取文件\t651\n14.8.1 实现file_read\t651\n14.8.2 实现sys_read与功能验证\t653\n14.9 实现文件读写指针定位功能\t655\n14.10 实现文件删除功能\t657\n14.10.1 回收inode\t657\n14.10.2 删除目录项\t660\n14.10.3 实现sys_unlink与功能验证\t663\n14.11 创建目录\t665\n14.11.1 实现sys_mkdir创建目录\t666\n14.11.2 创建目录功能验证\t669\n14.12 遍历目录\t671\n14.12.1 打开目录和关闭目录\t671\n14.12.2 读取1个目录项\t673\n14.12.3 实现sys_readdir及sys_\nrewinddir\t674\n14.13 删除目录\t676\n14.13.1 删除目录与判断空目录\t676\n14.13.2 实现sys_rmdir及功能验证\t677\n14.14 任务的工作目录\t679\n14.14.1 显示当前工作目录的原理及\n基础代码\t679\n14.14.2 实现sys_getcwd\t681\n14.14.3 实现sys_chdir改变工作目录\t683\n14.15 获得文件属性\t684\n14.15.1 ls命令的幕后功臣\t684\n14.15.2 实现sys_stat\t685\n第15章 系统交互\t687\n15.1 fork的原理与实现\t687\n15.1.1 什么是fork\t687\n15.1.2 fork的实现\t689\n15.1.3 添加fork系统调用与实现init\n进程\t695\n15.2 添加read系统调用，获取键盘输入\t696\n15.3 添加putchar、clear系统调用\t697\n15.4 实现一个简单的shell\t699\n15.4.1 shell雏形\t699\n15.4.2 添加Ctrl+u和Ctrl+l快捷键\t701\n15.4.3 解析键入的字符\t703\n15.4.4 添加系统调用\t705\n15.4.5 路径解析转换\t708\n15.4.6 实现ls、cd、mkdir、ps、rm等\n命令\t712\n15.5 加载用户进程\t717\n15.5.1 实现exec\t717\n15.5.2 让shell支持外部命令\t723\n15.5.3 加载硬盘上的用户程序执行\t724\n15.5.4 使用户进程支持参数\t727\n15.6 实现系统调用wait和exit\t731\n15.6.1 wait和exit的作用\t731\n15.6.2 孤儿进程和僵尸进程\t732\n15.6.3 一些基础代码\t733\n15.6.4 实现wait和exit\t737\n15.6.5 实现cat命令\t741\n15.7 管道\t745\n15.7.1 管道的原理\t745\n15.7.2 管道的设计\t747\n15.7.3 管道的实现\t748\n15.7.4 利用管道实现进程间通信\t752\n15.7.5 在shell中支持管道\t754\n参考文献\t760",
      "pages": "759",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s28513411.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s28513411.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s28513411.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/26745156\/",
      "id": "26745156",
      "publisher": "人民邮电出版社",
      "isbn10": "7115414343",
      "isbn13": "9787115414342",
      "title": "操作系统真象还原",
      "url": "https:\/\/api.douban.com\/v2\/book\/26745156",
      "alt_title": "",
      "author_intro": "郑钢，毕业于北京大学，前百度运维高级工程师，对操作系统有深入的研究。好运动，喜钻研，热衷于尝试前沿技术，乐于分享学习成果。",
      "summary": "大学及研究生都有操作系统课程，这类人群具有很高的学术能力,但书中讲的过于抽象与晦涩，以至于很多学生对于此门课程恐惧到都提不出问题，只有会的人才能提出问题。操作系统理论书是无法让读者理解什么是操作系统的，学操作系统不能靠想像，他们需要看到具体的东西。\n绝大多数技术人都对操作系统怀着好奇的心，他们渴望一本告诉操作系统到底是什么的书，里面不要掺杂太多无关的管理性的东西，代码量不大且是现代操作系统雏形，他们渴望很快看到本质而不花费大量的时间成本。",
      "price": "108.00"
    }
  ]
}