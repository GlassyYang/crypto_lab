{
  "count": 5,
  "start": 0,
  "total": 5,
  "books": [
    {
      "rating": {
        "max": 10,
        "numRaters": 2589,
        "average": "9.5",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "Randal E.Bryant",
        "David O'Hallaron"
      ],
      "pubdate": "2004-5-1",
      "tags": [
        {
          "count": 2938,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 1800,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 1308,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 975,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 890,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 436,
          "name": "程序员",
          "title": "程序员"
        },
        {
          "count": 409,
          "name": "programming",
          "title": "programming"
        },
        {
          "count": 338,
          "name": "OS",
          "title": "OS"
        }
      ],
      "origin_title": "Computer Systems: A Programmer's Perspective",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1470003.jpg",
      "binding": "平装",
      "translator": [
        "龚奕利",
        "雷迎春"
      ],
      "catalog": "出版说明\n关于第二次印刷的几点说明\n译 序\n关于术语的翻译\n在第二次印刷中一些重要术语的修订\n前 言\n关于作者\n第1章 计算机系统漫游\n1．1 信息就是位十上下文\n1．2 程序被其他程序翻译成不同的格式\n1．3 了解编译系统如何工作是大有益处的\n1．4 处理器读并解释储存在存储器中的指令\n1．5 高速缓存\n1．6 形成层次结构的存储设备\n1．7 操作系统管理硬件\n1．8 利用网络系统和其他系统通信\n1．9 下一步\n1．10 小结\n第1部分 程序结构和执行\n第2章 信息的表示和处理\n.2．1 信息存储\n2．2 整数表示\n2．3 整数运算\n2．4 浮点\n2．5 小结\n第3章 程序的机器级表示\n3．1 历史观点\n3．2 程序编码\n3．3 数据格式\n3．4 访问信息\n3．5 算术和逻辑操作\n3．6 控制\n3．7 过程\n3．8 数组分配和访问\n3．9 异类的数据结构\n3．10 对齐(alignment)\n3．11 综合：理解指针\n3．12 现实生活：使用gdb调试器\n3．13 存储器的越界引用和缓冲区溢出\n3．14 *浮点代码\n3．15 *在c程序中嵌入汇编代码\n3．16 小结\n第4章 处理器体系结构\n4．1 y86指令集体系结构\n4．2 逻辑设计和硬件控制语言hcl\n4．3 y86的顺序(sequential)实现\n4．4 流水线的通用原理\n4．5 y86的流水线实现\n4．6 小结\n第5章 优化程序性能\n5．1 优化编译器的能力和局限性\n5．2 表示程序性能\n5．3 程序示例\n5．4 消除循环的低效率\n5．5 减少过程调用\n5．6 消除不必要的存储器引用\n5．7 理解现代处理器\n5．8 降低循环开销\n5．9 转换到指针代码\n5．10 提高并行性\n5．11 综合：优化合并(combing)代码的效果小结\n5．12 转移预测和预测错误处罚\n5．13 解存储器性能\n5．14 现实生活：性能提高技术\n5．15 确认和消除性能瓶颈\n5．16 小结\n第6章 存储器层次结构\n6．1 存储技术\n6．2 局部性\n6．3 存储器层次结构\n6．4 高速缓存存储器\n6．5 编写高速缓存友好的代码\n6．6 综合：高速缓存对程序性能的影响\n6．7 综合：利用程序中的局部性\n6．8 小结\n第2部分 在系统上运行程序\n第7章 链接\n7．1 编译器驱动程序\n7．2 静态链接\n7．3 标文件\n7．4 可重定位目标文件\n7．5 符号和符号表\n7．6 符号解析\n7．7 重定位\n7．8 可执行目标文件\n7．9 加载可执行目标文件\n7．10 动态链接共享库\n7．11 从应用程序中加载和链接共享库\n7．12 *与位置无关的代码(pic)\n7．13 处理目标文件的工具\n7．14 小结\n第8章 异常控制流\n8．1 异常\n8．2 进程\n8．3 系统调用和错误处理\n8．4 进程控制\n8．5 信号\n8．6 非本地跳转\n8．7 操作进程的工具\n8．8 小结\n第9章 测量程序执行时间\n9．1 计算机系统上的时间流\n9．2 通过间隔计数(interval counting)来测量时间\n9．3 周期计数器\n9．4 用周期计数器来测量程序执行时间\n9．5 基于gettimeofday函数的测量\n9．6 综合：一个实验协议\n9．7 展望未来\n9．8 现实生活：k次最优测量方法\n9．9 得到的经验教训\n9．10 小结\n第10章 虚拟存储器\n10．1 物理和虚拟寻址\n10．2 地址空间\n10．3 虚拟存储器作为缓存的工具\n10．4 虚拟存储器作为存储器管理的工具\n10．5 虚拟存储器作为存储器保护的工具\n10．6 地址翻译\n10．7 案例研究：pentium／linux存储器系统，\n10．8 存储器映射\n10．9 动态存储器分配\n10．10 垃圾收集\n10．11 c程序中常见的与存储器有关的错误\n10．12 扼要重述一些有关虚拟存储器的关键概念\n10．13 小结\n第3部分 程序间的交互和通信\n第11章 系统级i／o\n11．1 unix i／o\n11．2 打开和关闭文件\n11．3 读和写文件\n11．4 用rio包进行健壮地读和写\n11．5 读取文件元数据\n11．6 共享文件\n11．7 i／o重定向\n11．8 标准i／o\n11．9 综合：我该使用哪些i／o函数?\n11．10 小结\n第12章 网络编程\n12．1 客户端-服务器编程模型\n12．2 网络\n12．3 全球ip因特网\n12．4 套接字接口\n12．5 web服务器\n12．6 综合：tinyweb服务器\n12．7 小结\n第13章 并发编程\n13．1 基于进程的并发编程\n13．2 基于i／o多路复用的并发编程\n13．3 基于线程的并发编程\n13．4 多线程程序中的共享变量\n13．5 用信号量同步线程\n13．6 综合：基于预线程化的并发服务器\n13．7 其他并发性问题\n13．8 小结\n附录a 处理器控制逻辑的hcl描述\na．1 hcl参考手册\na．2 seq\na．3 seq+\na．4 pipe\n附录b 错误处理\nb．1 unix系统中的错误处理\nb．2 错误处理封装函数\nb．3 csapp．h头文件\nb．4 csapp．c源文件\n参考文献\n索 引",
      "pages": "873",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s1470003.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s1470003.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s1470003.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1230413\/",
      "id": "1230413",
      "publisher": "中国电力出版社",
      "isbn10": "7508321758",
      "isbn13": "9787508321752",
      "title": "深入理解计算机系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1230413",
      "alt_title": "Computer Systems: A Programmer's Perspective",
      "author_intro": "Randal E. Bryant 1973年获得密歇根大学（University of Michigan）学士学位，随即就读麻省理工学院（Massachusetts Institute of Technology）的研究生院，并在1981年获计算机博士学位。他在加州理工学院（California Institute of Technology）做了三年助教，从1984年至今一直是卡内基梅隆大学（Carnegie Mellon）的教师。他现在是计算机科学的主任级教授和计算机科学系的系主任。他同时还受邀于电子和计算机工程系。 他从事本科和研究生计算机系统方面课程的教学超过20年。在讲授计算机体系结构课程多年后，他开始把关注点从如何设计计算机转移到程序员如何在更好地了解系统的情况下编写出更有效和更可靠的程序。他和O’Hallaron教授一起在卡内基梅隆大学开设了“计算机系统导论”课程，那便是此书的基础。他还教授一些算法和编程方面的课程。 Bryant教授的研究涉及帮助硬件设计者验证其系统正确性的软件工具的设计。其中，包括几种类型的模拟器，以及用数学方法来证明设计正确性的形式化验证工具。他发表了100多篇技术论文。包括Intel、Motorola、IBM和Fujitsu在内的主要计算机制造商都使用他的研究成果。他还因他的研究获得过数项大奖。其中包括Semiconductor Research Corporation颁发的两个发明荣誉奖和一个技术成就奖，美国计算机学会（Association for Computer Machinery，ACM）颁发的Kanellakis理论与实践奖，还有电气和电子工程师协会（Institute of Electrical and Electronics Engineers，IEEE）授予的W. R. G. Baker奖和50年金质奖章（a Golden Jubilee Medal）。他同时是ACM和IEEE的院士。\nDavid R. O’Hallaron 1986年在维吉尼亚大学（University of Virginia）获得计算机科学的博士学位。在通用电气工作一段时间后，于1989年作为系统科学家成为卡内基梅隆大学的教员。他目前是计算机科学系和电子及计算机工程系的副教授。 他教授一些本科生和研究生的计算机系统方面的课程，例如计算机体系结构、计算机系统绪论、并行处理器设计和Internet服务。和Bryant教授一起，他开设了“计算机系统导论”课程，那便是此书的基础。 O’Hallaron教授和他的学生从事计算机系统领域的研究。特别的，他们开发了一些软件系统，帮助科学家和工程师在计算机上模拟自然界。其中最著名的是Quake项目，一群计算机科学家、土木工程师和地震学家致力于在强烈地震中预测大地运动的能力，这些强烈地震包括南加洲、古巴、日本、墨西哥和新西兰的大地震。同Quake项目中其它人员一起，他获得了CMU计算机科学院颁发的Allen Newell优秀研究奖章。他为Quake项目创立的基准程序，183.equake，被SPEC（Standards Performance Evaluation Corporation）选入非常有影响的SPEC CPU和OMP（Open Mp）基准程序包中。",
      "summary": "从程序员的视角，看计算机系统！\n本书适用于那些想要写出更快、更可靠程序的程序员。通过掌握程序是如何映射到系统上，以及程序是如何执行的，读者能够更好的理解程序的行为为什么是这样的，以及效率低下是如何造成的。粗略来看，计算机系统包括处理器和存储器硬件、编译器、操作系统和网络互连环境。而通过程序员的视角，读者可以清晰地明白学习计算机系统的内部工作原理会对他们今后作为计算机科学研究者和工程师的工作有进一步的帮助。它还有助于为进一步学习计算机体系结构、操作系统、编译器和网络互连做好准备。\n本书的主要论题包括：数据表示、C程序的机器级表示、处理器结构，程序优化、存储器层次结构、链接、异常控制流、虚拟存储器和存储器管理、系统级I\/O、网络编程和并发编程。书中所覆盖的内容主要是这些方面是如何影响应用和系统程序员的。例如，在讲述数据表示时，本书说明了用来表示数字的表示方法是有限的，它能够近似地表示整数和实数，但是这种表示方法是有限制的，程序员必须了解。在讲述高速缓存时，本书讨论了矩阵代码中的循环变量的顺序是如何影响程序的性能的。在讨论网络互连时，本书描述了并发服务器如何能有效地处理来自多个客户端的请求。\n本书基于Intel兼容（IA32）机器，在Unix或者相关的操作系统（例如，Linux）上执行C程序。虽然书中包括了一些帮助读者将Java转化成C的提示，但是还是要求读者对C或者C++有一定的了解。\n您可以通过本书的Web网站www.csapp.cs.cmu.edu获得完整的资料，包括实验和作业，授课笔记和代码示例。\n本书英文版久负盛名，被众多专业人士称为“最伟大的计算机教材”之一，著名的美国卡内基梅隆大学计算机科学系一直将本书作为教材使用，程序员眼中的透彻讲述计算机系统的扛鼎之作。作者Randal E. Bryant是卡耐基梅隆大学的计算机科学系主任，ACM和IEEE双院士（Fellow），其研究成果多次获得ACM和IEEE颁发的大奖。\n本书共分十三章，分别介绍了信息的表示和处理、程序的机器级表示、处理器体系结构、存储器层次结构、静态和动态链接、虚拟存储器、系统级I\/O、网络编程和并发编程等精彩内容。其目的是解释计算机系统的所有本质概念，并向读者展示这些概念是如何实际地影响应用程序的正确性、性能和实用性。与其他主要针对系统构造人员的系统类书籍不同，这本书是写给程序员的，是从程序员的角度来描述的。本书为软件和硬件之间搭起了一个桥梁，它给出了一种帮助读者分别从硬件和软件的角度去理解一个程序及其行为的途径，这也填补了国内计算机系统教学中的一个空白。本书的最大优点是帮助读者理解概念，让读者很清楚地在脑海中构造一个层次型的计算机系统，从最低层数据在内存中的表示（如我们一直陌生的浮点数表示），到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户应用。\n本书提供了大量的例子和练习及部分答案。尤其值得一提的是，对于每一个基本概念都有相应的笔头或程序试验，加深读者的理解。",
      "price": "85.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 2205,
        "average": "9.7",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "（美）Randal E.Bryant",
        "David O'Hallaron"
      ],
      "pubdate": "2011-1-1",
      "tags": [
        {
          "count": 2544,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 1790,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 1418,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 975,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 875,
          "name": "操作系统&体系结构",
          "title": "操作系统&体系结构"
        },
        {
          "count": 753,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 527,
          "name": "体系结构",
          "title": "体系结构"
        },
        {
          "count": 470,
          "name": "程序员",
          "title": "程序员"
        }
      ],
      "origin_title": "Computer Systems: A Programmer's Perspective",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s4510534.jpg",
      "binding": "平装",
      "translator": [
        "龚奕利",
        "雷迎春"
      ],
      "catalog": "出版者的话\n译者序\n前　言\n第1章　计算机系统漫游1\n1.1　信息就是位+上下文1\n1.2　程序被其他程序翻译成不同的格式3\n1.3　了解编译系统如何工作是大有益处的4\n1.4　处理器读并解释存储在存储器中的指令5\n1.4.1　系统的硬件组成5\n1.4.2　运行hello程序7\n1.5　高速缓存至关重要7\n1.6　存储设备形成层次结构9\n1.7　操作系统管理硬件10\n1.7.1　进程11\n1.7.2　线程12\n1.7.3　虚拟存储器12\n1.7.4　文件13\n1.8　系统之间利用网络通信13\n1.9　重要主题15\n1.9.1　并发和并行15\n1.9.2　计算机系统中抽象的重要性17\n1.10　小结17\n参考文献说明18\n第一部分　程序结构和执行\n第2章　信息的表示和处理20\n2.1　信息存储22\n2.1.1　十六进制表示法22\n2.1.2　字25\n2.1.3　数据大小25\n2.1.4　寻址和字节顺序26\n2.1.5　表示字符串31\n2.1.6　表示代码31\n2.1.7　布尔代数简介32\n2.1.8　C语言中的位级运算34\n2.1.9　C语言中的逻辑运算36\n2.1.10　C语言中的移位运算36\n2.2　整数表示38\n2.2.1　整型数据类型38\n2.2.2　无符号数的编码39\n2.2.3　补码编码40\n2.2.4　有符号数和无符号数之间的转换44\n2.2.5　C语言中的有符号数与无符号数47\n2.2.6　扩展一个数字的位表示49\n2.2.7　截断数字51\n2.2.8　关于有符号数与无符号数的建议52\n2.3　整数运算54\n2.3.1　无符号加法54\n2.3.2　补码加法57\n2.3.3　补码的非59\n2.3.4　无符号乘法60\n2.3.5　补码乘法60\n2.3.6　乘以常数63\n2.3.7　除以2的幂64\n2.3.8　关于整数运算的最后思考67\n2.4　浮点数67\n2.4.1　二进制小数68\n2.4.2　IEEE浮点表示70\n2.4.3　数字示例71\n2.4.4　舍入74\n2.4.5　浮点运算76\n2.4.6　C语言中的浮点数77\n2.5　小结79\n参考文献说明80\n家庭作业80\n练习题答案90\n第3章　程序的机器级表示102\n3.1　历史观点103\n3.2　程序编码105\n3.2.1　机器级代码106\n3.2.2　代码示例107\n3.2.3　关于格式的注解109\n3.3　数据格式111\n3.4　访问信息112\n3.4.1　操作数指示符112\n3.4.2　数据传送指令114\n3.4.3　数据传送示例116\n3.5　算术和逻辑操作118\n3.5.1　加载有效地址118\n3.5.2　一元操作和二元操作119\n3.5.3　移位操作120\n3.5.4　讨论120\n3.5.5　特殊的算术操作122\n3.6　控制123\n3.6.1　条件码124\n3.6.2　访问条件码125\n3.6.3　跳转指令及其编码127\n3.6.4　翻译条件分支129\n3.6.5　循环132\n3.6.6　条件传送指令139\n3.6.7　switch语句144\n3.7　过程149\n3.7.1　栈帧结构149\n3.7.2　转移控制150\n3.7.3　寄存器使用惯例151\n3.7.4　过程示例152\n3.7.5　递归过程156\n3.8　数组分配和访问158\n3.8.1　基本原则158\n3.8.2　指针运算159\n3.8.3　嵌套的数组159\n3.8.4　定长数组161\n3.8.5　变长数组163\n3.9　异质的数据结构164\n3.9.1　结构164\n3.9.2　联合167\n3.9.3　数据对齐170\n3.10　综合：理解指针172\n3.11　应用：使用GDB调试器174\n3.12　存储器的越界引用和缓冲区溢出175\n3.13　x86-64：将IA32扩展到64位183\n3.13.1　x86-64的历史和动因184\n3.13.2　x86-64简介185\n3.13.3　访问信息187\n3.13.4　控制192\n3.13.5　数据结构200\n3.13.6　关于x86-64的总结性评论200\n3.14　浮点程序的机器级表示201\n3.15　小结201\n参考文献说明202\n家庭作业202\n练习题答案212\n第4章　处理器体系结构230\n4.1　Y86指令集体系结构231\n4.1.1　程序员可见的状态231\n4.1.2　Y86指令232\n4.1.3　指令编码233\n4.1.4　Y86异常237\n4.1.5　Y86程序237\n4.1.6　一些Y86指令的详情241\n4.2　逻辑设计和硬件控制语言HCL242\n4.2.1　逻辑门243\n4.2.2　组合电路和HCL布尔表达式243\n4.2.3　字级的组合电路和HCL整数表达式245\n4.2.4　集合关系248\n4.2.5　存储器和时钟248\n4.3　Y86的顺序实现250\n4.3.1　将处理组织成阶段250\n4.3.2　SEQ硬件结构258\n4.3.3　SEQ的时序259\n4.3.4　SEQ阶段的实现262\n4.4　流水线的通用原理267\n4.4.1　计算流水线268\n4.4.2　流水线操作的详细说明269\n4.4.3　流水线的局限性271\n4.4.4　带反馈的流水线系统272\n4.5　Y86的流水线实现273\n4.5.1　SEQ+：重新安排计算阶段273\n4.5.2　插入流水线寄存器276\n4.5.3　对信号进行重新排列和标号277\n4.5.4　预测下一个PC279\n4.5.5　流水线冒险280\n4.5.6　用暂停来避免数据冒险283\n4.5.7　用转发来避免数据冒险285\n4.5.8　加载\/使用数据冒险288\n4.5.9　异常处理289\n4.5.10　PIPE各阶段的实现291\n4.5.11　流水线控制逻辑297\n4.5.12　性能分析305\n4.5.13　未完成的工作306\n4.6　小结308\n参考文献说明309\n家庭作业309\n练习题答案314\n第5章　优化程序性能324\n5.1　优化编译器的能力和局限性325\n5.2　表示程序性能328\n5.3　程序示例330\n5.4　消除循环的低效率332\n5.5　减少过程调用336\n5.6　消除不必要的存储器引用336\n5.7　理解现代处理器340\n5.7.1　整体操作340\n5.7.2　功能单元的性能343\n5.7.3　处理器操作的抽象模型344\n5.8　循环展开348\n5.9　提高并行性351\n5.9.1　多个累积变量351\n5.9.2　重新结合变换354\n5.10　优化合并代码的结果小结358\n5.11　一些限制因素359\n5.11.1　寄存器溢出359\n5.11.2　分支预测和预测错误处罚360\n5.12　理解存储器性能363\n5.12.1　加载的性能363\n5.12.2　存储的性能364\n5.13　应用：性能提高技术369\n5.14　确认和消除性能瓶颈369\n5.14.1　程序剖析370\n5.14.2　使用剖析程序来指导优化371\n5.14.3　Amdahl定律374\n5.15　小结375\n参考文献说明375\n家庭作业376\n练习题答案378\n第6章　存储器层次结构382\n6.1 　存储技术382\n6.1.1　随机访问存储器383\n6.1.2　磁盘存储389\n6.1.3　固态硬盘398\n6.1.4　存储技术趋势399\n6.2　局部性401\n6.2.1　对程序数据引用的局部性402\n6.2.2　取指令的局部性403\n6.2.3　局部性小结403\n6.3　存储器层次结构405\n6.3.1　存储器层次结构中的缓存406\n6.3.2　存储器层次结构概念小结408\n6.4　高速缓存存储器408\n6.4.1　通用的高速缓存存储器结构409\n6.4.2　直接映射高速缓存410\n6.4.3　组相联高速缓存416\n6.4.4　全相联高速缓存418\n6.4.5　有关写的问题420\n6.4.6　一个真实的高速缓存层次结构的解剖421\n6.4.7　高速缓存参数的性能影响422\n6.5　编写高速缓存友好的代码423\n6.6　综合：高速缓存对程序性能的影响426\n6.6.1　存储器山426\n6.6.2　重新排列循环以提高空间局部性430\n6.6.3　在程序中利用局部性433\n6.7　小结433\n参考文献说明434\n家庭作业434\n练习题答案442\n第二部分　在系统上运行程序\n第7章　链接448\n7.1　编译器驱动程序449\n7.2　静态链接450\n7.3　目标文件450\n7.4　可重定位目标文件451\n7.5　符号和符号表452\n7.6　符号解析454\n7.6.1　链接器如何解析多重定义的全局符号455\n7.6.2　与静态库链接457\n7.6.3　链接器如何使用静态库来解析引用460\n7.7　重定位461\n7.7.1　重定位条目461\n7.7.2　重定位符号引用462\n7.8　可执行目标文件465\n7.9　加载可执行目标文件466\n7.10　动态链接共享库467\n7.11　从应用程序中加载和链接共享库468\n7.12　与位置无关的代码（PIC）471\n7.13　处理目标文件的工具473\n7.14　小结473\n参考文献说明474\n家庭作业474\n练习题答案479\n第8章　异常控制流480\n8.1　异常481\n8.1.1　异常处理481\n8.1.2　异常的类别482\n8.1.3　Linux\/IA32系统中的异常484\n8.2　进程487\n8.2.1　逻辑控制流487\n8.2.2　并发流487\n8.2.3　私有地址空间488\n8.2.4　用户模式和内核模式488\n8.2.5　上下文切换489\n8.3　系统调用错误处理491\n8.4　进程控制492\n8.4.1　获取进程ID492\n8.4.2　创建和终止进程492\n8.4.3　回收子进程495\n8.4.4　让进程休眠499\n8.4.5　加载并运行程序500\n8.4.6　利用fork和execve运行程序502\n8.5　信号504\n8.5.1　信号术语505\n8.5.2　发送信号506\n8.5.3　接收信号509\n8.5.4　信号处理问题511\n8.5.5　可移植的信号处理516\n8.5.6　显式地阻塞和取消阻塞信号517\n8.5.7　同步流以避免讨厌的并发错误517\n8.6　非本地跳转521\n8.7　操作进程的工具524\n8.8　小结524\n参考文献说明525\n家庭作业525\n练习题答案530\n第9章　虚拟存储器534\n9.1　物理和虚拟寻址535\n9.2　地址空间535\n9.3　虚拟存储器作为缓存的工具536\n9.3.1　DRAM缓存的组织结构537\n9.3.2　页表537\n9.3.3　页命中538\n9.3.4　缺页538\n9.3.5　分配页面539\n9.3.6　又是局部性救了我们539\n9.4　虚拟存储器作为存储器管理的工具540\n9.5　虚拟存储器作为存储器保护的工具541\n9.6　地址翻译542\n9.6.1　结合高速缓存和虚拟存储器544\n9.6.2　利用TLB加速地址翻译545\n9.6.3　多级页表546\n9.6.4　综合：端到端的地址翻译547\n9.7　案例研究：Intel Core i7\/Linux存储器系统550\n9.7.1　Core i7地址翻译551\n9.7.2　Linux虚拟存储器系统554\n9.8　存储器映射556\n9.8.1　再看共享对象557\n9.8.2　再看fork函数558\n9.8.3　再看execve函数559\n9.8.4　使用mmap函数的用户级存储器映射559\n9.9　动态存储器分配561\n9.9.1　malloc和free函数561\n9.9.2　为什么要使用动态存储器分配563\n9.9.3　分配器的要求和目标564\n9.9.4　碎片565\n9.9.5　实现问题565\n9.9.6　隐式空闲链表565\n9.9.7　放置已分配的块567\n9.9.8　分割空闲块567\n9.9.9　获取额外的堆存储器567\n9.9.10　合并空闲块568\n9.9.11　带边界标记的合并568\n9.9.12　综合：实现一个简单的分配器570\n9.9.13　显式空闲链表576\n9.9.14　分离的空闲链表576\n9.10　垃圾收集578\n9.10.1　垃圾收集器的基本知识579\n9.10.2　Mark&Sweep垃圾收集器580\n9.10.3　C程序的保守Mark&Sweep580\n9.11　C程序中常见的与存储器有关的错误581\n9.11.1　间接引用坏指针582\n9.11.2　读未初始化的存储器582\n9.11.3　允许栈缓冲区溢出582\n9.11.4　假设指针和它们指向的对象是相同大小的583\n9.11.5　造成错位错误583\n9.11.6　引用指针，而不是它所指向的对象583\n9.11.7　误解指针运算584\n9.11.8　引用不存在的变量584\n9.11.9　引用空闲堆块中的数据584\n9.11.10　引起存储器泄漏585\n9.12　小结585\n参考文献说明586\n家庭作业586\n练习题答案589\n第三部分　程序间的交互和通信\n第10章　系统级I\/O596\n10.1　Unix I\/O596\n10.2　打开和关闭文件597\n10.3　读和写文件598\n10.4　用RIO包健壮地读写599\n10.4.1　RIO的无缓冲的输入输出函数600\n10.4.2　RIO的带缓冲的输入函数600\n10.5　读取文件元数据604\n10.6　共享文件606\n10.7　I\/O重定向608\n10.8　标准I\/O609\n10.9　综合：我该使用哪些I\/O函数610\n10.10　小结611\n参考文献说明612\n家庭作业612\n练习题答案612\n第11章　网络编程614\n11.1　客户端-服务器编程模型614\n11.2　网络615\n11.3　全球IP因特网618\n11.3.1　IP地址619\n11.3.2　因特网域名620\n11.3.3　因特网连接623\n11.4　套接字接口625\n11.4.1　套接字地址结构625\n11.4.2　socket函数626\n11.4.3　connect函数626\n11.4.4　open_clientfd函数627\n11.4.5　bind函数628\n11.4.6　listen函数628\n11.4.7　open_listenfd函数628\n11.4.8　accept函数629\n11.4.9　echo客户端和服务器的示例630\n11.5　Web服务器633\n11.5.1　Web基础633\n11.5.2　Web内容633\n11.5.3　HTTP事务634\n11.5.4　服务动态内容636\n11.6　综合：TINY Web服务器639\n11.7　小结645\n参考文献说明645\n家庭作业646\n练习题答案646\n第12章　并发编程648\n12.1　基于进程的并发编程649\n12.1.1　基于进程的并发服务器649\n12.1.2  关于进程的优劣651\n12.2　基于I\/O多路复用的并发编程651\n12.2.1　基于I\/O多路复用的并发事件驱动服务器653\n12.2.2　I\/O多路复用技术的优劣657\n12.3　基于线程的并发编程657\n12.3.1　线程执行模型657\n12.3.2　Posix线程658\n12.3.3　创建线程659\n12.3.4　终止线程659\n12.3.5　回收已终止线程的资源660\n12.3.6　分离线程660\n12.3.7　初始化线程660\n12.3.8　一个基于线程的并发服务器661\n12.4　多线程程序中的共享变量662\n12.4.1　线程存储器模型663\n12.4.2　将变量映射到存储器663\n12.4.3　共享变量664\n12.5　用信号量同步线程664\n12.5.1　进度图667\n12.5.2　信号量668\n12.5.3　使用信号量来实现互斥669\n12.5.4　利用信号量来调度共享资源670\n12.5.5　综合：基于预线程化的并发服务器674\n12.6　使用线程提高并行性676\n12.7　其他并发问题680\n12.7.1　线程安全680\n12.7.2　可重入性682\n12.7.3　在线程化的程序中使用已存在的库函数682\n12.7.4　竞争683\n12.7.5　死锁685\n12.8　小结687\n参考文献说明687\n家庭作业688\n练习题答案691\n附录Ａ　错误处理694\nA.1　Unix系统中的错误处理694\nA.2 　错误处理包装函数696\n参考文献698",
      "pages": "702",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s4510534.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s4510534.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s4510534.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/5333562\/",
      "id": "5333562",
      "publisher": "机械工业出版社",
      "isbn10": "7111321332",
      "isbn13": "9787111321330",
      "title": "深入理解计算机系统（原书第2版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/5333562",
      "alt_title": "Computer Systems: A Programmer's Perspective",
      "author_intro": "Randal E.Bryant　1973年于密歇根大学（University of Michigan）获得学士学位，随即就读于麻省理工学院的研究生院，并在1981年获计算机博士学位。他在加州理工学院（California Institute of Technology）做了三年助教，从1984年至今一直是卡内基-梅隆大学的教师。他现在是计算机科学的大学教授和计算机科学学院的院长。他同时还受邀于电子和计算机工程系。\n他从事本科生和研究生计算机系统方面课程的教学超过30年。在讲授计算机体系结构课程多年后，他开始把关注点从如何设计计算机转移到程序员如何在更好的了解系统的情况下编写出更有效和更可靠的程序。他和O’Hallaron教授一起在卡内基梅隆大学开设了15-213“计算机系统导论”课程，那便是此书的基础。他还教授一些有关算法、编程、计算机网络和VLSI（超大规模集成电路）设计方面的课程。\nBryant教授的主要研究内容是设计软件工具来帮助软件和硬件设计者验证其系统正确性。其中，包括几种类型的模拟器，以及用数学方法来证明设计正确性的形式化验证工具。他发表了150多篇技术论文。包括Intel、FreeScale、IBM和Fujitsu在内的主要计算机制造商都使用着他的研究成果。他还因他的研究获得过数项大奖。其中包括Semiconductor Research Corporation颁发的两个发明荣誉奖和一个技术成就奖，ACM颁发的Kanellakis理论与实践奖，还有IEEE授予的W.R.G.Baker奖、Emmanuel Piore奖和Phil Kaufman奖。他还是ACM院士、IEEE院士和美国国家工程院院士。\nDavid R.O’Hallaron 现为Intel匹兹堡实验室主任，卡内基-梅隆大学电子和计算机工程系副教授。在弗吉尼亚大学获得计算机科学的博士学位。\n他教授本科生和研究生的计算机系统方面的课程，例如计算机体系结构、计算机系统导论、并行处理器设计和Internet服务。他和Bryant教授一起开设了“计算机系统导论”课程，那便是此书的基础。2004年他获得了CMU计算机学院颁发的Herbert Simon杰出教学奖，这个奖项的获得者是基于学生的投票产生的。\nO’Hallaron教授从事计算机系统领域的研究，主要兴趣在于科学计算、数据密集型计算和虚拟化方面的软件系统。其中最著名的是Quake项目，一群计算机科学家、土木工程师和地震学家致力于提高对强烈地震中大地运动的预测能力。2003年，他同Quake项目中其他成员一起获得了高性能计算领域中的最高国际奖项—Gordon Bell奖。",
      "summary": "本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。全书共12章，主要内容包括信息的表示和处理、程序的机器级表示、处理器体系结构、优化程序性能、存储器层次结构、链接、异常控制流、虚拟存储器、系统级I\/O、网络编程、并发编程等。书中提供大量的例子和练习，并给出部分答案，有助于读者加深对正文所述概念和知识的理解。\n本书的最大优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统，从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。通过掌握程序是如何映射到系统上，以及程序是如何执行的，读者能够更好地理解程序的行为为什么是这样的，以及效率低下是如何造成的。\n本书适合那些想要写出更快、更可靠程序的程序员阅读，也适合作为高等院校计算机及相关专业本科生、研究生的教材。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "99.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 287,
        "average": "9.7",
        "min": 0
      },
      "subtitle": "Computer Systems: A Programmer's Perspective",
      "author": [
        "（美）Randal E.Bryant, David R.O'Hallaron"
      ],
      "pubdate": "2006-7",
      "tags": [
        {
          "count": 290,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 189,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 173,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 96,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 89,
          "name": "CSAPP",
          "title": "CSAPP"
        },
        {
          "count": 87,
          "name": "系统体系结构",
          "title": "系统体系结构"
        },
        {
          "count": 68,
          "name": "计算机结构",
          "title": "计算机结构"
        },
        {
          "count": 54,
          "name": "Programming",
          "title": "Programming"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\/view\/subject\/m\/public\/s2008433.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "",
      "pages": "978",
      "images": {
        "small": "https://img3.doubanio.com\/view\/subject\/s\/public\/s2008433.jpg",
        "large": "https://img3.doubanio.com\/view\/subject\/l\/public\/s2008433.jpg",
        "medium": "https://img3.doubanio.com\/view\/subject\/m\/public\/s2008433.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/1896753\/",
      "id": "1896753",
      "publisher": "电子工业出版社",
      "isbn10": "7121025809",
      "isbn13": "9787121025808",
      "title": "深入理解计算机系统",
      "url": "https:\/\/api.douban.com\/v2\/book\/1896753",
      "alt_title": "A Programmer's Perspective",
      "author_intro": "",
      "summary": "《深入理解计算机系统》(英文版)主要介绍了计算机系统的基本概念，包括最底层的内存中的数据表示、流水线指令的构成、虚拟存储器、编译系统、动态加载库，以及用户应用等。书中提供了大量实际操作，可以帮助读者更好地理解程序执行的方式，改进程序的执行效率。此书以程序员的视角全面讲解了计算机系统，深入浅出地介绍了处理器、编译器、操作系统和网络环境，是这一领域的权威之作。",
      "series": {
        "id": "35164",
        "title": "国外计算机科学教材系列"
      },
      "price": "89.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 417,
        "average": "9.8",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "Randal E.Bryant",
        "David O'Hallaron"
      ],
      "pubdate": "2016-11",
      "tags": [
        {
          "count": 356,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 321,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 282,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 188,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 178,
          "name": "计算机体系结构",
          "title": "计算机体系结构"
        },
        {
          "count": 170,
          "name": "CSAPP",
          "title": "CSAPP"
        },
        {
          "count": 152,
          "name": "计算机底层",
          "title": "计算机底层"
        },
        {
          "count": 105,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "Computer Systems: A Programmer's Perspective (3rd Edition)",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29195878.jpg",
      "binding": "平装",
      "translator": [
        "龚奕利",
        "贺莲"
      ],
      "catalog": "出版者的话\n中文版序一\n中文版序二\n译者序\n前言\n关于作者\n第1章　计算机系统漫游1\n1.1　信息就是位+上下文1\n1.2　程序被其他程序翻译成不同的格式3\n1.3　了解编译系统如何工作是大有益处的4\n1.4　处理器读并解释储存在内存中的指令5\n1.4.1　系统的硬件组成5\n1.4.2　运行hello程序7\n1.5　高速缓存至关重要9\n1.6　存储设备形成层次结构9\n1.7　操作系统管理硬件10\n1.7.1　进程11\n1.7.2　线程12\n1.7.3　虚拟内存12\n1.7.4　文件14\n1.8　系统之间利用网络通信14\n1.9　重要主题16\n1.9.1　Amdahl定律16\n1.9.2　并发和并行17\n1.9.3　计算机系统中抽象的重要性19\n1.10　小结20\n参考文献说明20\n练习题答案20\n第一部分\n程序结构和执行\n第2章　信息的表示和处理22\n2.1　信息存储24\n2.1.1　十六进制表示法25\n2.1.2　字数据大小27\n2.1.3　寻址和字节顺序29\n2.1.4　表示字符串34\n2.1.5　表示代码34\n2.1.6　布尔代数简介35\n2.1.7　C语言中的位级运算37\n2.1.8　C语言中的逻辑运算39\n2.1.9　C语言中的移位运算40\n2.2　整数表示41\n2.2.1　整型数据类型42\n2.2.2　无符号数的编码43\n2.2.3　补码编码44\n2.2.4　有符号数和无符号数之间的转换49\n2.2.5　C语言中的有符号数与无符号数52\n2.2.6　扩展一个数字的位表示54\n2.2.7　截断数字56\n2.2.8　关于有符号数与无符号数的建议58\n2.3　整数运算60\n2.3.1　无符号加法60\n2.3.2　补码加法62\n2.3.3　补码的非66\n2.3.4　无符号乘法67\n2.3.5　补码乘法67\n2.3.6　乘以常数70\n2.3.7　除以2的幂71\n2.3.8　关于整数运算的最后思考74\n2.4　浮点数75\n2.4.1　二进制小数76\n2.4.2　IEEE浮点表示78\n2.4.3　数字示例79\n2.4.4　舍入83\n2.4.5　浮点运算85\n2.4.6　C语言中的浮点数86\n2.5　小结87\n参考文献说明88\n家庭作业88\n练习题答案97\n第3章　程序的机器级表示109\n3.1　历史观点110\n3.2　程序编码113\n3.2.1　机器级代码113\n3.2.2　代码示例114\n3.2.3　关于格式的注解117\n3.3　数据格式119\n3.4　访问信息119\n3.4.1　操作数指示符121\n3.4.2　数据传送指令122\n3.4.3　数据传送示例125\n3.4.4　压入和弹出栈数据127\n3.5　算术和逻辑操作128\n3.5.1　加载有效地址129\n3.5.2　一元和二元操作130\n3.5.3　移位操作131\n3.5.4　讨论131\n3.5.5　特殊的算术操作133\n3.6　控制135\n3.6.1　条件码135\n3.6.2　访问条件码136\n3.6.3　跳转指令138\n3.6.4　跳转指令的编码139\n3.6.5　用条件控制来实现条件分支…141\n3.6.6　用条件传送来实现条件分支…145\n3.6.7　循环149\n3.6.8　switch语句159\n3.7　过程164\n3.7.1　运行时栈164\n3.7.2　转移控制165\n3.7.3　数据传送168\n3.7.4　栈上的局部存储170\n3.7.5　寄存器中的局部存储空间172\n3.7.6　递归过程174\n3.8　数组分配和访问176\n3.8.1　基本原则176\n3.8.2　指针运算177\n3.8.3　嵌套的数组178\n3.8.4　定长数组179\n3.8.5　变长数组181\n3.9　异质的数据结构183\n3.9.1　结构183\n3.9.2　联合186\n3.9.3　数据对齐189\n3.10　在机器级程序中将控制与数据结合起来192\n3.10.1　理解指针192\n3.10.2　应用：使用GDB调试器193\n3.10.3　内存越界引用和缓冲区溢出194\n3.10.4　对抗缓冲区溢出攻击198\n3.10.5　支持变长栈帧201\n3.11　浮点代码204\n3.11.1　浮点传送和转换操作205\n3.11.2　过程中的浮点代码209\n3.11.3　浮点运算操作210\n3.11.4　定义和使用浮点常数212\n3.11.5　在浮点代码中使用位级操作212\n3.11.6　浮点比较操作213\n3.11.7　对浮点代码的观察结论215\n3.12　小结216\n参考文献说明216\n家庭作业216\n练习题答案226\n第4章　处理器体系结构243\n4.1　Y86-64指令集体系结构245\n4.1.1　程序员可见的状态245\n4.1.2　Y86-64指令245\n4.1.3　指令编码246\n4.1.4　Y86-64异常250\n4.1.5　Y86-64程序251\n4.1.6　一些Y86-64指令的详情255\n4.2　逻辑设计和硬件控制语言HCL256\n4.2.1　逻辑门257\n4.2.2　组合电路和HCL布尔表达式257\n4.2.3　字级的组合电路和HCL整数表达式258\n4.2.4　集合关系261\n4.2.5　存储器和时钟262\n4.3　Y86-64的顺序实现264\n4.3.1　将处理组织成阶段264\n4.3.2　SEQ硬件结构272\n4.3.3　SEQ的时序274\n4.3.4　SEQ阶段的实现277\n4.4　流水线的通用原理282\n4.4.1　计算流水线282\n4.4.2　流水线操作的详细说明284\n4.4.3　流水线的局限性284\n4.4.4　带反馈的流水线系统287\n4.5　Y86-64的流水线实现288\n4.5.1　SEQ+：重新安排计算阶段288\n4.5.2　插入流水线寄存器289\n4.5.3　对信号进行重新排列和标号292\n4.5.4　预测下一个PC293\n4.5.5　流水线冒险295\n4.5.6　异常处理306\n4.5.7　PIPE各阶段的实现308\n4.5.8　流水线控制逻辑314\n4.5.9　性能分析322\n4.5.10　未完成的工作323\n4.6　小结325\n参考文献说明326\n家庭作业327\n练习题答案331\n第5章　优化程序性能341\n5.1　优化编译器的能力和局限性342\n5.2　表示程序性能345\n5.3　程序示例347\n5.4　消除循环的低效率350\n5.5　减少过程调用353\n5.6　消除不必要的内存引用354\n5.7　理解现代处理器357\n5.7.1　整体操作357\n5.7.2　功能单元的性能361\n5.7.3　处理器操作的抽象模型362\n5.8　循环展开366\n5.9　提高并行性369\n5.9.1　多个累积变量370\n5.9.2　重新结合变换373\n5.10　优化合并代码的结果小结377\n5.11　一些限制因素378\n5.11.1　寄存器溢出378\n5.11.2　分支预测和预测错误处罚379\n5.12　理解内存性能382\n5.12.1　加载的性能382\n5.12.2　存储的性能383\n5.13　应用：性能提高技术387\n5.14　确认和消除性能瓶颈388\n5.14.1　程序剖析388\n5.14.2　使用剖析程序来指导优化390\n5.15　小结392\n参考文献说明393\n家庭作业393\n练习题答案395\n第6章　存储器层次结构399\n6.1　存储技术399\n6.1.1　随机访问存储器400\n6.1.2　磁盘存储406\n6.1.3　固态硬盘414\n6.1.4　存储技术趋势415\n6.2　局部性418\n6.2.1　对程序数据引用的局部性418\n6.2.2　取指令的局部性419\n6.2.3　局部性小结420\n6.3　存储器层次结构421\n6.3.1　存储器层次结构中的缓存422\n6.3.2　存储器层次结构概念小结424\n6.4　高速缓存存储器425\n6.4.1　通用的高速缓存存储器组织结构425\n6.4.2　直接映射高速缓存427\n6.4.3　组相联高速缓存433\n6.4.4　全相联高速缓存434\n6.4.5　有关写的问题437\n6.4.6　一个真实的高速缓存层次结构的解剖438\n6.4.7　高速缓存参数的性能影响439\n6.5　编写高速缓存友好的代码440\n6.6　综合：高速缓存对程序性能的影响444\n6.6.1　存储器山444\n6.6.2　重新排列循环以提高空间局部性447\n6.6.3　在程序中利用局部性450\n6.7　小结450\n参考文献说明451\n家庭作业451\n练习题答案459\n第二部分\n在系统上运行程序\n第7章　链接464\n7.1　编译器驱动程序465\n7.2　静态链接466\n7.3　目标文件466\n7.4　可重定位目标文件467\n7.5　符号和符号表468\n7.6　符号解析470\n7.6.1　链接器如何解析多重定义的全局符号471\n7.6.2　与静态库链接475\n7.6.3　链接器如何使用静态库来解析引用477\n7.7　重定位478\n7.7.1　重定位条目479\n7.7.2　重定位符号引用479\n7.8　可执行目标文件483\n7.9　加载可执行目标文件484\n7.10　动态链接共享库485\n7.11　从应用程序中加载和链接共享库487\n7.12　位置无关代码489\n7.13　库打桩机制492\n7.13.1　编译时打桩492\n7.13.2　链接时打桩492\n7.13.3　运行时打桩494\n7.14　处理目标文件的工具496\n7.15　小结496\n参考文献说明497\n家庭作业497\n练习题答案499\n第8章　异常控制流501\n8.1　异常502\n8.1.1　异常处理503\n8.1.2　异常的类别504\n8.1.3　Linux\/x86-64系统中的异常505\n8.2　进程508\n8.2.1　逻辑控制流508\n8.2.2　并发流509\n8.2.3　私有地址空间509\n8.2.4　用户模式和内核模式510\n8.2.5　上下文切换511\n8.3　系统调用错误处理512\n8.4　进程控制513\n8.4.1　获取进程ID513\n8.4.2　创建和终止进程513\n8.4.3　回收子进程516\n8.4.4　让进程休眠521\n8.4.5　加载并运行程序521\n8.4.6　利用fork和execve运行程序524\n8.5　信号526\n8.5.1　信号术语527\n8.5.2　发送信号528\n8.5.3　接收信号531\n8.5.4　阻塞和解除阻塞信号532\n8.5.5　编写信号处理程序533\n8.5.6　同步流以避免讨厌的并发错误540\n8.5.7　显式地等待信号543\n8.6　非本地跳转546\n8.7　操作进程的工具550\n8.8　小结550\n参考文献说明550\n家庭作业550\n练习题答案556\n第9章　虚拟内存559\n9.1　物理和虚拟寻址560\n9.2　地址空间560\n9.3　虚拟内存作为缓存的工具561\n9.3.1　DRAM缓存的组织结构562\n9.3.2　页表562\n9.3.3　页命中563\n9.3.4　缺页564\n9.3.5　分配页面565\n9.3.6　又是局部性救了我们565\n9.4　虚拟内存作为内存管理的工具565\n9.5　虚拟内存作为内存保护的工具567\n9.6　地址翻译567\n9.6.1　结合高速缓存和虚拟内存570\n9.6.2　利用TLB加速地址翻译570\n9.6.3　多级页表571\n9.6.4　综合：端到端的地址翻译573\n9.7　案例研究：Intel Core i7\/Linux内存系统576\n9.7.1　Core i7地址翻译576\n9.7.2　Linux虚拟内存系统580\n9.8　内存映射582\n9.8.1　再看共享对象583\n9.8.2　再看fork函数584\n9.8.3　再看execve函数584\n9.8.4　使用mmap函数的用户级内存映射585\n9.9　动态内存分配587\n9.9.1　malloc和free函数587\n9.9.2　为什么要使用动态内存分配589\n9.9.3　分配器的要求和目标590\n9.9.4　碎片591\n9.9.5　实现问题592\n9.9.6　隐式空闲链表592\n9.9.7　放置已分配的块593\n9.9.8　分割空闲块594\n9.9.9　获取额外的堆内存594\n9.9.10　合并空闲块594\n9.9.11　带边界标记的合并595\n9.9.12　综合：实现一个简单的分配器597\n9.9.13　显式空闲链表603\n9.9.14　分离的空闲链表604\n9.10　垃圾收集605\n9.10.1　垃圾收集器的基本知识606\n9.10.2　Mark&Sweep垃圾收集器607\n9.10.3　C程序的保守Mark&Sweep608\n9.11　C程序中常见的与内存有关的错误609\n9.11.1　间接引用坏指针609\n9.11.2　读未初始化的内存609\n9.11.3　允许栈缓冲区溢出610\n9.11.4　假设指针和它们指向的对象是相同大小的610\n9.11.5　造成错位错误611\n9.11.6　引用指针，而不是它所指向的对象611\n9.11.7　误解指针运算611\n9.11.8　引用不存在的变量612\n9.11.9　引用空闲堆块中的数据612\n9.11.10　引起内存泄漏613\n9.12　小结613\n参考文献说明613\n家庭作业614\n练习题答案617\n第三部分\n程序间的交互和通信\n第10章　系统级I\/O622　10.1　Unix I\/O622\n10.2　文件623\n10.3　打开和关闭文件624\n10.4　读和写文件625\n10.5　用RIO包健壮地读写626\n10.5.1　RIO的无缓冲的输入输出函数627\n10.5.2　RIO的带缓冲的输入函数627\n10.6　读取文件元数据632\n10.7　读取目录内容633\n10.8　共享文件634\n10.9　I\/O重定向637\n10.10　标准I\/O638\n10.11　综合：我该使用哪些I\/O函数？638\n10.12　小结640\n参考文献说明640\n家庭作业640\n练习题答案641\n第11章　网络编程642\n11.1　客户端服务器编程模型642\n11.2　网络643\n11.3　全球IP因特网646\n11.3.1　IP地址647\n11.3.2　因特网域名649\n11.3.3　因特网连接651\n11.4　套接字接口652\n11.4.1　套接字地址结构653\n11.4.2　socket函数654\n11.4.3　connect函数654\n11.4.4　bind函数654\n11.4.5　listen函数655\n11.4.6　accept函数655\n11.4.7　主机和服务的转换656\n11.4.8　套接字接口的辅助函数660\n11.4.9　echo客户端和服务器的示例662\n11.5　Web服务器665\n11.5.1　Web基础665\n11.5.2　Web内容666\n11.5.3　HTTP事务667\n11.5.4　服务动态内容669\n11.6　综合：TINY Web服务器671\n11.7　小结678\n参考文献说明678\n家庭作业678\n练习题答案679\n第12章　并发编程681\n12.1　基于进程的并发编程682\n12.2　基于I\/O多路复用的并发编程684\n12.3　基于线程的并发编程691\n12.4　多线程程序中的共享变量696\n12.5　用信号量同步线程698\n12.6　使用线程提高并行性710\n12.7　其他并发问题716\n12.8　小结722\n参考文献说明723\n家庭作业723\n练习题答案726\n附录A　错误处理729\n参考文献733",
      "pages": "737",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s29195878.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s29195878.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s29195878.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/26912767\/",
      "id": "26912767",
      "publisher": "机械工业出版社",
      "isbn10": "7111544935",
      "isbn13": "9787111544937",
      "title": "深入理解计算机系统（原书第3版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/26912767",
      "alt_title": "Computer Systems: A Programmer's Perspective (3rd Edition)",
      "author_intro": "Randal E. Bryant，1981年于麻省理工学院获得计算机博士学位，1984年至今一直任教于卡内基-梅隆大学。现任卡内基-梅隆大学计算机科学学院院长、教授，同时还受邀任教于电子和计算机工程系。他从事本科生和研究生计算机系统方面课程的教学近40年。他和O’Hallaron教授一起在卡内基梅隆大学开设了15-213课程“计算机系统导论”，那便是本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国人文与科学研究院院士。其研究成果被Intel、IBM、Fujitsu和Microsoft等主要计算机制造商使用，他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。\n\nDavid R. O’Hallaron卡内基梅隆大学电子和计算机工程系教授。在弗吉尼亚大学（University of Virginia）获得计算机科学的博士学位，2007年-2010年为Intel匹兹堡实验室主任。他教授本科生和研究生的计算机系统方面的课程已有20余年，并和Bryant教授一起开设了“计算机系统导论”课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究，与Quake项目成员一起获得过高性能计算领域中的*高国际奖项——Gordon Bell奖。他目前的工作重点是研究自动分级（autograding）概念，即评价其他程序质量的程序。",
      "summary": "和第2版相比，本版内容上*大的变化是，从以IA32和x86-64为基础转变为完全以x86-64为基础。主要更新如下：\n基于x86-64，大量地重写代码，首次介绍对处理浮点数据的程序的机器级支持。\n处理器体系结构修改为支持64位字和操作的设计。\n引入更多的功能单元和更复杂的控制逻辑，使基于程序数据流表示的程序性能模型预测更加可靠。\n扩充关于用GOT和PLT创建与位置无关代码的讨论，描述了更加强大的链接技术（比如库打桩）。\n增加了对信号处理程序更细致的描述，包括异步信号安全的函数等。\n采用新函数，更新了与协议无关和线程安全的网络编程。",
      "series": {
        "id": "1163",
        "title": "计算机科学丛书"
      },
      "price": "139.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 250,
        "average": "9.8",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[美] Randal E. Bryant",
        "[美] David R. O'Hallaron"
      ],
      "pubdate": "2011-1",
      "tags": [
        {
          "count": 234,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 158,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 136,
          "name": "计算机体系结构",
          "title": "计算机体系结构"
        },
        {
          "count": 93,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 92,
          "name": "计算机系统",
          "title": "计算机系统"
        },
        {
          "count": 83,
          "name": "经典",
          "title": "经典"
        },
        {
          "count": 57,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 50,
          "name": "Computer-Science",
          "title": "Computer-Science"
        }
      ],
      "origin_title": "Computer systems : a programmer's perspective",
      "image": "https://img1.doubanio.com\/view\/subject\/m\/public\/s4572259.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "第1章　计算机系统漫游1\n1.1　信息就是位+上下文1\n1.2　程序被其他程序翻译成不同的格式3\n1.3　了解编译系统如何工作是大有益处的4\n1.4　处理器读并解释存储在存储器中的指令5\n1.4.1　系统的硬件组成5\n1.4.2　运行hello程序7\n1.5　高速缓存至关重要7\n1.6　存储设备形成层次结构9\n1.7　操作系统管理硬件10\n1.7.1　进程11\n1.7.2　线程12\n1.7.3　虚拟存储器12\n1.7.4　文件13\n1.8　系统之间利用网络通信13\n1.9　重要主题15\n1.9.1　并发和并行15\n1.9.2　计算机系统中抽象的重要性17\n1.10　小结17\n参考文献说明18\n.第一部分　程序结构和执行\n第2章　信息的表示和处理20\n2.1　信息存储22\n2.1.1　十六进制表示法22\n2.1.2　字25\n2.1.3　数据大小25\n2.1.4　寻址和字节顺序26\n2.1.5　表示字符串31\n2.1.6　表示代码31\n2.1.7　布尔代数简介32\n2.1.8　c语言中的位级运算34\n2.1.9　c语言中的逻辑运算36\n2.1.10　c语言中的移位运算36\n2.2　整数表示38\n2.2.1　整型数据类型38\n2.2.2　无符号数的编码39\n2.2.3　补码编码40\n2.2.4　有符号数和无符号数之间的转换44\n2.2.5　c语言中的有符号数与无符号数47\n2.2.6　扩展一个数字的位表示49\n2.2.7　截断数字51\n2.2.8　关于有符号数与无符号数的建议52\n2.3　整数运算54\n2.3.1　无符号加法54\n2.3.2　补码加法57\n2.3.3　补码的非59\n2.3.4　无符号乘法60\n2.3.5　补码乘法60\n2.3.6　乘以常数63\n2.3.7　除以2的幂64\n2.3.8　关于整数运算的最后思考67\n2.4　浮点数67\n2.4.1　二进制小数68\n2.4.2　ieee浮点表示70\n2.4.3　数字示例71\n2.4.4　舍入74\n2.4.5　浮点运算76\n2.4.6　c语言中的浮点数77\n2.5　小结79\n参考文献说明80\n家庭作业80\n练习题答案90\n第3章　程序的机器级表示102\n3.1　历史观点103\n3.2　程序编码105\n3.2.1　机器级代码106\n3.2.2　代码示例107\n3.2.3　关于格式的注解109\n3.3　数据格式111\n3.4　访问信息112\n3.4.1　操作数指示符112\n3.4.2　数据传送指令114\n3.4.3　数据传送示例116\n3.5　算术和逻辑操作118\n3.5.1　加载有效地址118\n3.5.2　一元操作和二元操作119\n3.5.3　移位操作120\n3.5.4　讨论120\n3.5.5　特殊的算术操作122\n3.6　控制123\n3.6.1　条件码124\n3.6.2　访问条件码125\n3.6.3　跳转指令及其编码127\n3.6.4　翻译条件分支129\n3.6.5　循环132\n3.6.6　条件传送指令139\n3.6.7　switch语句144\n3.7　过程149\n3.7.1　栈帧结构149\n3.7.2　转移控制150\n3.7.3　寄存器使用惯例151\n3.7.4　过程示例152\n3.7.5　递归过程156\n3.8　数组分配和访问158\n3.8.1　基本原则158\n3.8.2　指针运算159\n3.8.3　嵌套的数组159\n3.8.4　定长数组161\n3.8.5　变长数组163\n3.9　异质的数据结构164\n3.9.1　结构164\n3.9.2　联合167\n3.9.3　数据对齐170\n3.10　综合：理解指针172\n3.11　应用：使用gdb调试器174\n3.12　存储器的越界引用和缓冲区溢出175\n3.13　x86-64：将ia32扩展到64位183\n3.13.1　x86-64的历史和动因184\n3.13.2　x86-64简介185\n3.13.3　访问信息187\n3.13.4　控制192\n3.13.5　数据结构200\n3.13.6　关于x86-64的总结性评论200\n3.14　浮点程序的机器级表示201\n3.15　小结201\n参考文献说明202\n家庭作业202\n练习题答案212\n第4章　处理器体系结构230\n4.1　y86指令集体系结构231\n4.1.1　程序员可见的状态231\n4.1.2　y86指令232\n4.1.3　指令编码233\n4.1.4　y86异常237\n4.1.5　y86程序237\n4.1.6　一些y86指令的详情241\n4.2　逻辑设计和硬件控制语言hcl242\n4.2.1　逻辑门243\n4.2.2　组合电路和hcl布尔表达式243\n4.2.3　字级的组合电路和hcl整数表达式245\n4.2.4　集合关系248\n4.2.5　存储器和时钟248\n4.3　y86的顺序实现250\n4.3.1　将处理组织成阶段250\n4.3.2　seq硬件结构258\n4.3.3　seq的时序259\n4.3.4　seq阶段的实现262\n4.4　流水线的通用原理267\n4.4.1　计算流水线268\n4.4.2　流水线操作的详细说明269\n4.4.3　流水线的局限性271\n4.4.4　带反馈的流水线系统272\n4.5　y86的流水线实现273\n4.5.1　seq+：重新安排计算阶段273\n4.5.2　插入流水线寄存器276\n4.5.3　对信号进行重新排列和标号277\n4.5.4　预测下一个pc279\n4.5.5　流水线冒险280\n4.5.6　用暂停来避免数据冒险283\n4.5.7　用转发来避免数据冒险285\n4.5.8　加载\/使用数据冒险288\n4.5.9　异常处理289\n4.5.10　pipe各阶段的实现291\n4.5.11　流水线控制逻辑297\n4.5.12　性能分析305\n4.5.13　未完成的工作306\n4.6　小结308\n参考文献说明309\n家庭作业309\n练习题答案314\n第5章　优化程序性能324\n5.1　优化编译器的能力和局限性325\n5.2　表示程序性能328\n5.3　程序示例330\n5.4　消除循环的低效率332\n5.5　减少过程调用336\n5.6　消除不必要的存储器引用336\n5.7　理解现代处理器340\n5.7.1　整体操作340\n5.7.2　功能单元的性能343\n5.7.3　处理器操作的抽象模型344\n5.8　循环展开348\n5.9　提高并行性351\n5.9.1　多个累积变量351\n5.9.2　重新结合变换354\n5.10　优化合并代码的结果小结358\n5.11　一些限制因素359\n5.11.1　寄存器溢出359\n5.11.2　分支预测和预测错误处罚360\n5.12　理解存储器性能363\n5.12.1　加载的性能363\n5.12.2　存储的性能364\n5.13　应用：性能提高技术369\n5.14　确认和消除性能瓶颈369\n5.14.1　程序剖析370\n5.14.2　使用剖析程序来指导优化371\n5.14.3　amdahl定律374\n5.15　小结375\n参考文献说明375\n家庭作业376\n练习题答案378\n第6章　存储器层次结构382\n6.1 　存储技术382\n6.1.1　随机访问存储器383\n6.1.2　磁盘存储389\n6.1.3　固态硬盘398\n6.1.4　存储技术趋势399\n6.2　局部性401\n6.2.1　对程序数据引用的局部性402\n6.2.2　取指令的局部性403\n6.2.3　局部性小结403\n6.3　存储器层次结构405\n6.3.1　存储器层次结构中的缓存406\n6.3.2　存储器层次结构概念小结408\n6.4　高速缓存存储器408\n6.4.1　通用的高速缓存存储器结构409\n6.4.2　直接映射高速缓存410\n6.4.3　组相联高速缓存416\n6.4.4　全相联高速缓存418\n6.4.5　有关写的问题420\n6.4.6　一个真实的高速缓存层次结构的解剖421\n6.4.7　高速缓存参数的性能影响422\n6.5　编写高速缓存友好的代码423\n6.6　综合：高速缓存对程序性能的影响426\n6.6.1　存储器山426\n6.6.2　重新排列循环以提高空间局部性430\n6.6.3　在程序中利用局部性433\n6.7　小结433\n参考文献说明434\n家庭作业434\n练习题答案442\n第二部分　在系统上运行程序\n第7章　链接448\n7.1　编译器驱动程序449\n7.2　静态链接450\n7.3　目标文件450\n7.4　可重定位目标文件451\n7.5　符号和符号表452\n7.6　符号解析454\n7.6.1　链接器如何解析多重定义的全局符号455\n7.6.2　与静态库链接457\n7.6.3　链接器如何使用静态库来解析引用460\n7.7　重定位461\n7.7.1　重定位条目461\n7.7.2　重定位符号引用462\n7.8　可执行目标文件465\n7.9　加载可执行目标文件466\n7.10　动态链接共享库467\n7.11　从应用程序中加载和链接共享库468\n7.12　与位置无关的代码（pic）471\n7.13　处理目标文件的工具473\n7.14　小结473\n参考文献说明474\n家庭作业474\n练习题答案479\n第8章　异常控制流480\n8.1　异常481\n8.1.1　异常处理481\n8.1.2　异常的类别482\n8.1.3　linux\/ia32系统中的异常484\n8.2　进程487\n8.2.1　逻辑控制流487\n8.2.2　并发流487\n8.2.3　私有地址空间488\n8.2.4　用户模式和内核模式488\n8.2.5　上下文切换489\n8.3　系统调用错误处理491\n8.4　进程控制492\n8.4.1　获取进程id492\n8.4.2　创建和终止进程492\n8.4.3　回收子进程495\n8.4.4　让进程休眠499\n8.4.5　加载并运行程序500\n8.4.6　利用fork和execve运行程序502\n8.5　信号504\n8.5.1　信号术语505\n8.5.2　发送信号506\n8.5.3　接收信号509\n8.5.4　信号处理问题511\n8.5.5　可移植的信号处理516\n8.5.6　显式地阻塞和取消阻塞信号517\n8.5.7　同步流以避免讨厌的并发错误517\n8.6　非本地跳转521\n8.7　操作进程的工具524\n8.8　小结524\n参考文献说明525\n家庭作业525\n练习题答案530\n第9章　虚拟存储器534\n9.1　物理和虚拟寻址535\n9.2　地址空间535\n9.3　虚拟存储器作为缓存的工具536\n9.3.1　dram缓存的组织结构537\n9.3.2　页表537\n9.3.3　页命中538\n9.3.4　缺页538\n9.3.5　分配页面539\n9.3.6　又是局部性救了我们539\n9.4　虚拟存储器作为存储器管理的工具540\n9.5　虚拟存储器作为存储器保护的工具541\n9.6　地址翻译542\n9.6.1　结合高速缓存和虚拟存储器544\n9.6.2　利用tlb加速地址翻译545\n9.6.3　多级页表546\n9.6.4　综合：端到端的地址翻译547\n9.7　案例研究：intel core i7\/linux存储器系统550\n9.7.1　core i7地址翻译551\n9.7.2　linux虚拟存储器系统554\n9.8　存储器映射556\n9.8.1　再看共享对象557\n9.8.2　再看fork函数558\n9.8.3　再看execve函数559\n9.8.4　使用mmap函数的用户级存储器映射559\n9.9　动态存储器分配561\n9.9.1　malloc和free函数561\n9.9.2　为什么要使用动态存储器分配563\n9.9.3　分配器的要求和目标564\n9.9.4　碎片565\n9.9.5　实现问题565\n9.9.6　隐式空闲链表565\n9.9.7　放置已分配的块567\n9.9.8　分割空闲块567\n9.9.9　获取额外的堆存储器567\n9.9.10　合并空闲块568\n9.9.11　带边界标记的合并568\n9.9.12　综合：实现一个简单的分配器570\n9.9.13　显式空闲链表576\n9.9.14　分离的空闲链表576\n9.10　垃圾收集578\n9.10.1　垃圾收集器的基本知识579\n9.10.2　mark&sweep垃圾收集器580\n9.10.3　c程序的保守mark&sweep580\n9.11　c程序中常见的与存储器有关的错误581\n9.11.1　间接引用坏指针582\n9.11.2　读未初始化的存储器582\n9.11.3　允许栈缓冲区溢出582\n9.11.4　假设指针和它们指向的对象是相同大小的583\n9.11.5　造成错位错误583\n9.11.6　引用指针，而不是它所指向的对象583\n9.11.7　误解指针运算584\n9.11.8　引用不存在的变量584\n9.11.9　引用空闲堆块中的数据584\n9.11.10　引起存储器泄漏585\n9.12　小结585\n参考文献说明586\n家庭作业586\n练习题答案589\n第三部分　程序间的交互和通信\n第10章　系统级i\/o596\n10.1　unix i\/o596\n10.2　打开和关闭文件597\n10.3　读和写文件598\n10.4　用rio包健壮地读写599\n10.4.1　rio的无缓冲的输入输出函数600\n10.4.2　rio的带缓冲的输入函数600\n10.5　读取文件元数据604\n10.6　共享文件606\n10.7　i\/o重定向608\n10.8　标准i\/o609\n10.9　综合：我该使用哪些i\/o函数610\n10.10　小结611\n参考文献说明612\n家庭作业612\n练习题答案612\n第11章　网络编程614\n11.1　客户端-服务器编程模型614\n11.2　网络615\n11.3　全球ip因特网618\n11.3.1　ip地址619\n11.3.2　因特网域名620\n11.3.3　因特网连接623\n11.4　套接字接口625\n11.4.1　套接字地址结构625\n11.4.2　socket函数626\n11.4.3　connect函数626\n11.4.4　open_clientfd函数627\n11.4.5　bind函数628\n11.4.6　listen函数628\n11.4.7　open_listenfd函数628\n11.4.8　accept函数629\n11.4.9　echo客户端和服务器的示例630\n11.5　web服务器633\n11.5.1　web基础633\n11.5.2　web内容633\n11.5.3　http事务634\n11.5.4　服务动态内容636\n11.6　综合：tiny web服务器639\n11.7　小结645\n参考文献说明645\n家庭作业646\n练习题答案646\n第12章　并发编程648\n12.1　基于进程的并发编程649\n12.1.1　基于进程的并发服务器649\n12.1.2 关于进程的优劣651\n12.2　基于i\/o多路复用的并发编程651\n12.2.1　基于i\/o多路复用的并发事件驱动服务器653\n12.2.2　i\/o多路复用技术的优劣657\n12.3　基于线程的并发编程657\n12.3.1　线程执行模型657\n12.3.2　posix线程658\n12.3.3　创建线程659\n12.3.4　终止线程659\n12.3.5　回收已终止线程的资源660\n12.3.6　分离线程660\n12.3.7　初始化线程660\n12.3.8　一个基于线程的并发服务器661\n12.4　多线程程序中的共享变量662\n12.4.1　线程存储器模型663\n12.4.2　将变量映射到存储器663\n12.4.3　共享变量664\n12.5　用信号量同步线程664\n12.5.1　进度图667\n12.5.2　信号量668\n12.5.3　使用信号量来实现互斥669\n12.5.4　利用信号量来调度共享资源670\n12.5.5　综合：基于预线程化的并发服务器674\n12.6　使用线程提高并行性676\n12.7　其他并发问题680\n12.7.1　线程安全680\n12.7.2　可重入性682\n12.7.3　在线程化的程序中使用已存在的库函数682\n12.7.4　竞争683\n12.7.5　死锁685\n12.8　小结687\n参考文献说明687\n家庭作业688\n练习题答案691\n附录ａ　错误处理694\na.1　unix系统中的错误处理694\na.2 　错误处理包装函数696\n参考文献698",
      "pages": "1077",
      "images": {
        "small": "https://img1.doubanio.com\/view\/subject\/s\/public\/s4572259.jpg",
        "large": "https://img1.doubanio.com\/view\/subject\/l\/public\/s4572259.jpg",
        "medium": "https://img1.doubanio.com\/view\/subject\/m\/public\/s4572259.jpg"
      },
      "alt": "https:\/\/book.douban.com\/subject\/5407246\/",
      "id": "5407246",
      "publisher": "机械工业出版社",
      "isbn10": "7111326318",
      "isbn13": "9787111326311",
      "title": "深入理解计算机系统（英文版·第2版）",
      "url": "https:\/\/api.douban.com\/v2\/book\/5407246",
      "alt_title": "Computer systems : a programmer's perspective",
      "author_intro": "Randal E. Bryant 1973年获得密歇根大学学士学位，随即就读麻省理工学院的研究生院，并在1981年获得计算机博士学位。从1984年至今一直任教于卡内基-梅隆大学，现在是卡内基-梅隆大学计算机学院院长、教授，同时受邀任教于电子与计算机工程学院。他还是ACM院士、IEEE院士和美国国家工程院院士。其研究成果获得过数项大奖，其中包括Semiconductor Research Corporation颁发的两个发明荣誉奖和一个技术成就奖，ACM颁发的Kanellakis理论与实践奖，还有IEEE授予的W. R. G. Baker奖、Emmanuel Piore奖和Phil Kaufman奖。\nDavid R. O'Hallaron 现为Intel匹兹堡实验室主任，卡内基-梅隆大学电子和计算机工程学院副教授，并在维吉尼亚大学（University of Virginia）获得计算机科学的博士学位。他曾获得卡内基-梅隆大学计算机学院颁发的Herbert Simon杰出教学奖，并同Quake项目中其他成员一起获得了高性能计算领域中的最高国际奖项——Gordon Bell奖。",
      "summary": "本书是一本将计算机软件和硬件理论结合讲述的经典教程，内容覆盖计算机导论、体系结构和处理器设计等多门课程。本书的最大优点是为程序员描述计算机系统的实现细节，通过描述程序是如何映射到系统上，以及程序是如何执行的，使读者更好地理解程序的行为为什么是这样的，以及造成效率低下的原因。\n相对于第1版，本版主要是反映了过去十年间硬件技术和编译器的变化，具体更新如下：\n1. 对系统的介绍（特别是实际使用部分）做了增加和修改。例如，既保持了原有的针对32位系统的说明，又增加了对64位系统的描述。\n2. 增加了很多关于由算术运算溢出以及缓冲区溢出造成安全漏洞的内容。\n3. 更详细讲述了处理器对异常的发现和处理。\n4. 描述了基于Intel Core i7处理器的存储器层次结构，还增加了固态硬盘的内容。\n5. 强调并发性，增加了关于并发性一般原则的内容。\n【编辑推荐】\n“2005年，我开始采用Bryant和O’Hallaron的这本书作为本科生计算机系统课程的教材。三年后，这本书仍然是我的计算机系统课程教科书的首选。” —— Mirela Damian，维拉诺瓦大学\n“本书表述清晰、恰到好处——举重若轻地呈现了那些非常复杂的内容。” —— Ibrahim Matta, 波士顿大学\n“这是一本学习计算机硬件和软件如何‘真正’协同工作的好书，还教会你为什么了解这些知识会使你成为一个更有价值的程序员。本书还帮你为学习像操作系统和编译器这样的高级课程做好准备。在本书中，我最喜欢的章节是关于缓存的，当我第一次发现缓存有多重要时，真是难以置信！” —— Vishal Shah，Ask.com总架构师",
      "series": {
        "id": "1895",
        "title": "经典原版书库"
      },
      "price": "128.00元"
    }
  ]
}
